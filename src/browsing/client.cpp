#include <unistd.h>
#include <iostream>
#include <iomanip>
#include <regex>

#include <settings.h>
#include <logger.h>
#include <server.h>
#include <globals.h>
#include <util.h>
#include <database.h>
#include <browsing/sb_crypt.h>
#include <browsing/constants.h>

#include <browsing/client.h>

typedef void (Browsing::Client::*RequestActionFunc)(const std::vector<unsigned char>&);

static std::map<uint8_t, RequestActionFunc> mRequestActions = 
{
	{ REQUEST_SERVER_LIST,    &Browsing::Client::requestServerList   },
	{ REQUEST_SERVER_INFO,    &Browsing::Client::requestServerInfo   },
	//{ REQUEST_SEND_MESSAGE,   &Browsing::Client::requestSendMessage  },
	//{ REQUEST_KEEPALIVE,      &Browsing::Client::requestKeepAlive    },
	//{ REQUEST_MAPLOOP,        &Browsing::Client::requestMapLoop      },
	//{ REQUEST_PLAYERSEARCH,   &Browsing::Client::requestPlayerSearch },
};

Browsing::Client::Client(int socket, struct sockaddr_in address)
{
	this->_socket = socket;
	this->_address = address;
}

Browsing::Client::~Client()
{
	this->Disconnect();
}

void Browsing::Client::Listen()
{
	while(true)
	{
		std::vector<unsigned char> buffer(4096, 0);
		
		int recv_size = read(this->_socket, &(buffer[0]), 4096);
		
		// If error or no data is recieved we end the connection
		if(recv_size <= 0)
		{
			break;
		}
		
		// Resize buffer
		buffer.resize(recv_size);
		
		this->_LogTransaction("-->", Util::Buffer::ToString(buffer));
		
		this->onRequest(buffer);
	}
	
	this->Disconnect();
}

void Browsing::Client::Disconnect()
{
	this->Close();
	g_browsing_server->onClientDisconnect(*this);
}

/*
	Events
*/
void Browsing::Client::onRequest(const std::vector<unsigned char>& request)
{
	int size = static_cast<uint16_t>(request[0]);
	uint8_t action = static_cast<uint8_t>(request[2]);
	
	// Find function
	auto it = mRequestActions.find(action);
	if (it != mRequestActions.end())
	{
		// Get Function address
		RequestActionFunc func = it->second;
	
		// Execute action function with class object.
		(this->*(func))(request);
	}
	else
	{
		Logger::warning("action \"" + std::to_string(action) + "\"not implemented!", Server::Type::Browsing);
		
		this->Disconnect();
	}
}

/*

	filter:
		gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=20 and xr>=20)and (region & 1)=0
		
		Min/Max Players:
			Max:				numplayers<=22
			Min:				numplayers>=1
		Game Mode:
			Conquest:			gc=0 and gametype='conquest'
			CTF:				gc=0 and gametype='capturetheflag'
		Maps: 
			Backstab:			mapname=0 and mc=1
			DeadlyPass:			mapname=1 and mc=1
			BridgeToFar:		mapname=2 and mc=1
			Dammage:			mapname=3 and mc=1
			HarborEdge:			mapname=4 and mc=1
			Honor:				mapname=5 and mc=1
			LittleBigEye:		mapname=6 and mc=1
			MissleCrisis		mapname=7 and mc=1
			ColdFront			mapname=8 and mc=1
			RussianBorder:		mapname=9 and mc=1
			SpecialOp:			mapname=10 and mc=1
			TheBlackGold		mapname=11 and mc=1
			TheNest				mapname=12 and mc=1
			[All Maps Playlist]	mc=2
			[Assualt Maps]		mc=3
			[Incursion Maps]	mc=4
			[Domination Maps]	mc=5
		Ranked:
			On:					(nr>1 or xr<20)
			Off:				nr=1 and xr=20
		Stats Tracking:
			On:					sr=1
			Off:				sr=0
		
		Clan fight:
			gamever='V1.31a' and (teamplay!=0 and (c0=-1 or c1=-1 or c0=19 or c1=19) and maxplayers<=24 and numplayers!=maxplayers and nr<=20 and xr>=20)and (region & 1)=0
			
			gamever='V1.31a' and (teamplay!=0 and (c0=-1 or c1=-1 or c0=21 or c1=21) and maxplayers<=24 and numplayers!=maxplayers and nr<=1 and xr>=1 and sr=1)and (region & 1)=0
			
			
*/
void Browsing::Client::requestServerList(const std::vector<unsigned char>& request)
{	
	if(request.size() < 50)
	{
		return;
	}
	
	size_t offset = 9;
	
	// Read for_gamename and from_gamename
	std::string for_gamename, from_gamename;
	if(!Util::Buffer::ReadString(request, offset, for_gamename) ||
		!Util::Buffer::ReadString(request, offset, from_gamename))
	{
		return;
	}
	
	// Copy client_challenge
	this->_client_challenge.assign(request.begin() + offset, request.begin() + offset + CHALLENGE_CLIENT_LEN);
	offset += CHALLENGE_CLIENT_LEN;
	
	// Read filter and key_list
	std::string filter, key_list;
	if(!Util::Buffer::ReadString(request, offset, filter) ||
		!Util::Buffer::ReadString(request, offset, key_list))
	{
		return;
	}
	
	// Debug
	//Logger::debug("for_gamename = " + for_gamename);
	//Logger::debug("from_gamename = " + from_gamename);
	//Logger::debug("filter = " + filter);
	//Logger::debug("key_list = " + key_list);
	
	Battlefield::GameServers game_servers;
	g_database->queryGameServers(game_servers);
	
	// Filter Game servers
	this->_FilterServers(filter, game_servers);
	
	std::vector<unsigned char> response(CHALLENGE_HEADER_LEN, 0x0);
	for(Battlefield::GameServer game_server : game_servers)
	{
		uint8_t ip[4];
		uint16_t port;
		uint8_t flag;
		
		//game_server.useExample();
		//game_server.Debug();
		
		if(!game_server.isVerified())
			continue;
		
		// Debug
		//Logger::debug("name = " + game_server.GetHostName());
		
		game_server.GetIpArray(ip);
		port = game_server.GetPort();
		flag = game_server.GetFlag();
		
		// Server flag
		response.push_back(flag);
		
		// wan ip
		response.insert(response.end(), ip, ip + 4);
		
		if(flag & FLAG_NONSTANDARD_PORT)         // -> wan port
		{
			response.push_back(port / 256);
			response.push_back(port % 256);
		}
		
		if(flag & FLAG_PRIVATE_IP)               // -> localip0 ip
		{              
			response.insert(response.end(), ip, ip + 4);
		}
		
		if(flag & FLAG_NONSTANDARD_PRIVATE_PORT) // -> localport
		{
			response.push_back(port / 256);
			response.push_back(port % 256);
		}
		
		if(flag & FLAG_ICMP_IP)                  // -> icmp ip
		{
			response.insert(response.end(), ip, ip + 4);
		}
	}
	
	// End data
	response.push_back(0x00); // Empty flag means end of servers
	
	// Add to data to say confirm decryption went correctly
	response.push_back(0xFF);
	response.push_back(0xFF);
	response.push_back(0xFF);
	response.push_back(0xFF);
	
	this->_Encrypt(this->_client_challenge, response);
	
	this->Send(response);
	
	this->_LogTransaction("<--", Util::Buffer::ToString(response));
}

void Browsing::Client::requestServerInfo(const std::vector<unsigned char>& request)
{
	std::vector<unsigned char> response(CHALLENGE_HEADER_LEN, 0x0);
	
	response.push_back(0x00);
	response.push_back(0x00);
	response.push_back(0x00);
	response.push_back(0x00);
	response.push_back(0x00);
	response.push_back(0x00);
	
	this->_Encrypt(this->_client_challenge, response);
	
	this->Send(response);
	
	this->_LogTransaction("<--", Util::Buffer::ToString(response));
}

/*
	Private functions
*/
void Browsing::Client::_LogTransaction(const std::string& direction, const std::string& response) const
{
	std::shared_lock<std::shared_mutex> guard2(g_mutex_settings); // settings lock  (read)
	
	bool show_console = (g_settings["browsing"]["show_requests"].asBool() && direction == "-->") ||
						(g_settings["browsing"]["show_responses"].asBool() && direction == "<--");
	
	Logger::info(this->GetAddress() + " " + direction + " " + response,
			Server::Type::Browsing, show_console);
}

void Browsing::Client::_FilterServers(const std::string& filter, Battlefield::GameServers& game_servers)
{
	Battlefield::GameServers::const_iterator game_server_it;

	for(game_server_it = game_servers.begin(); game_server_it != game_servers.end(); ++game_server_it)
	{
		// Check if server needs to be removed
		if(
			this->_FilterServerGameVersion(filter, *game_server_it) ||
			this->_FilterServerRegion(filter, *game_server_it) ||
			this->_FilterServerNumPlayers(filter, *game_server_it) ||
			this->_FilterServerGameType(filter, *game_server_it) ||
			this->_FilterServerMapName(filter, *game_server_it) ||
			this->_FilterServerStatsTracking(filter, *game_server_it) ||
			this->_FilterServerReconfigurable(filter, *game_server_it) ||
			this->_FilterServerClan(filter, *game_server_it) ||
			this->_FilterServerTeamplay(filter, *game_server_it)
		)
		{
			// Remove the game server out of the list
			game_servers.erase(game_server_it);
			
			// Go back one item value
			game_server_it--;
		}
	}
}

bool Browsing::Client::_FilterServerGameVersion(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: gamever='V1.31a'
	pattern = std::regex(R"(gamever='([^']+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		std::string gamever = matches[1];
		
		if(!(game_server.GetGameVersion() == gamever))
			return true; // remove server
	}

	return false; // Dont remove server
}

bool Browsing::Client::_FilterServerRegion(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: (region & 1)!=0
	pattern = std::regex(R"(\(region \& (\d+)\)!=0)");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		uint64_t v = std::stoull(matches[1]);
		
		if(!((game_server.GetRegion() & v) != 0))
			return true; // remove server
	}
	
	// Find: (region & 1)=0
	pattern = std::regex(R"(\(region \& (\d+)\)=0)");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		uint64_t v = std::stoull(matches[1]);
		
		if(!((game_server.GetRegion() & v) == 0))
			return true; // remove server
	}

	return false; // Dont remove server
}

bool Browsing::Client::_FilterServerNumPlayers(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: numplayers>=0
	pattern = std::regex(R"(numplayers>=(\d+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		uint8_t numplayers = std::stoul(matches[1]);
		
		if(!(game_server.GetNumPlayers() >= numplayers))
			return true; // remove server
	}
	
	// Find: numplayers<=23
	pattern = std::regex(R"(numplayers<=(\d+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		uint8_t numplayers = std::stoul(matches[1]);
		
		if(!(game_server.GetNumPlayers() <= numplayers))
			return true; // remove server
	}
	
	return false; // Dont remove server
}

bool Browsing::Client::_FilterServerGameType(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: gametype='conquest'
	pattern = std::regex(R"(gametype='([^']+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		std::string gametype = matches[1];
		
		if(!(game_server.GetGameType() == gametype))
			return true; // remove server
	}

	return false; // Dont remove server
}

bool Browsing::Client::_FilterServerMapName(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: mapname=2
	pattern = std::regex(R"(mapname=(\d+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		uint8_t mapname = std::stoul(matches[1]);
		
		if(!(game_server.GetMapName() == mapname))
			return true; // remove server
	}
	
	return false;
}

bool Browsing::Client::_FilterServerStatsTracking(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: mapname=2
	pattern = std::regex(R"(sr=(\d+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		uint8_t sr = std::stoul(matches[1]);
		
		if(!(game_server.GetStatsTracking() == sr))
			return true; // remove server
	}
	
	return false;
}

bool Browsing::Client::_FilterServerReconfigurable(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: (rc=1 or teamplay!=0)
	pattern = std::regex(R"(rc=(\d+) or teamplay!=(\d+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		
	}
	else
	{
		// Find: rc=2
		pattern = std::regex(R"(rc=(\d+))");
		if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
		{
			uint8_t rc = std::stoul(matches[1]);
			
			if(!(game_server.GetReconfigurable() == rc))
				return true; // remove server
		}
	}
	
	return false;
}

bool Browsing::Client::_FilterServerTeamplay(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: (rc=1 or teamplay!=0)
	pattern = std::regex(R"(rc=(\d+) or teamplay!=(\d+))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		uint8_t rc = std::stoul(matches[1]);
		uint8_t teamplay = std::stoul(matches[2]);
		
		if(!(game_server.GetReconfigurable() == rc || game_server.GetTeamplay() != teamplay))
			return true; // remove server
	}
	else
	{
		// Find: teamplay=0
		pattern = std::regex(R"(teamplay=(\d+))");
		if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
		{
			uint8_t teamplay = std::stoul(matches[1]);
			
			if(!(game_server.GetTeamplay() == teamplay))
				return true; // remove server
		}
		
		// Find: teamplay!=0
		pattern = std::regex(R"(teamplay!=(\d+))");
		if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
		{
			uint8_t teamplay = std::stoul(matches[1]);
			
			if(!(game_server.GetTeamplay() != teamplay))
				return true; // remove server
		}
	}

	return false; // Dont remove server
}

bool Browsing::Client::_FilterServerClan(const std::string& filter, const Battlefield::GameServer& game_server)
{
	std::regex pattern;
	std::smatch matches;
	
	// Find: (c0=33 or c1=33)
	pattern = std::regex(R"(\(c0=(\d+) or c1=(\d+)\))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		int32_t c0 = std::stoi(matches[1]);
		int32_t c1 = std::stoi(matches[2]);
		
		if(!(game_server.GetClan1Id() == c0 || game_server.GetClan2Id() == c1))
			return true; // remove server
	}
	
	//Find: (c0=-1 or c1=-1 or c0=33 or c1=33)
	pattern = std::regex(R"(\(c0=-1 or c1=-1 or c0=(\d+) or c1=(\d+)\))");
	if (std::regex_search(filter, matches, pattern) && matches.size() >= 2)
	{
		int32_t c0 = std::stoi(matches[1]);
		int32_t c1 = std::stoi(matches[2]);
		
		if(!(game_server.GetClan1Id() == -1 || game_server.GetClan2Id() == -1 ||
			game_server.GetClan1Id() == c0 || game_server.GetClan2Id() == c1))
			return true; // remove server
	}
	
	return false;
}

void Browsing::Client::_Encrypt(const std::vector<unsigned char>& client_challenge, std::vector<unsigned char>& response)
{
	uint8_t server_challenge[CHALLENGE_SERVER_LEN];
	uint8_t secret[CHALLENGE_CLIENT_LEN];
	
	GOACryptState m_crypt_state;
	
	// Push Crypt Challenge
	response[0] = 0xe6; // CHALLENGE_CRYPT_LEN ^ 0xec = 0xe6
	for(int i = 0; i < CHALLENGE_CRYPT_LEN; i++)
	{
		response[1 + i] = 0x0; // Emptry crypto challenge
	}

	// Push Server challenge
	response[CHALLENGE_CRYPT_LEN + 1] = 0xf3; // CHALLENGE_SERVER_LEN ^ 0xea = 0xf3
	for(int i = 0; i < CHALLENGE_SERVER_LEN; i++)
	{
		server_challenge[i] = 0x0;
		response[CHALLENGE_CRYPT_LEN + 2 + i] = server_challenge[i];
	}
	
	// Copy client challenge to secret
	for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
	{
		secret[i] = client_challenge[i];
	}
	
	// Generate secret encryption/decryption key
	for (uint32_t i = 0 ; i < CHALLENGE_SERVER_LEN; i++)
	{
		uint8_t index = (i *  SECRET_KEY[i % SECRET_KEY_LEN]) % CHALLENGE_CLIENT_LEN;
		uint8_t value = (secret[i % CHALLENGE_CLIENT_LEN] ^ server_challenge[i]) & 0xFF;
		
		secret[index] ^= value;
	}
	
	// Encrypt data
	GOACryptInit(&(m_crypt_state), (unsigned char *)(&secret), CHALLENGE_CLIENT_LEN);
	GOAEncrypt(&(m_crypt_state), &response[CHALLENGE_CRYPT_SERVER_LEN], response.size() - CHALLENGE_CRYPT_SERVER_LEN);
}

/*
	Example and test
*/
std::vector<unsigned char> example_A_request = {
	0x01, 0x5e,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x25, 0x60, 0x50, 0x27, 0x6c, 0x6d, 0x64, 0x55,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)!=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x21, 0x3d, 0x30, 0x00,
	
	// key_list: \hostname\gametype\gamever\hostport\timelimit\timeelapsed\mapname\numplayers\maxplayers\
	             teamplay\team_t\ping_\c0\c1\n0\n1\c0c\c1c\nr\xr\ff\mc\gc\rc\sr\ni\xi\qm
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x14, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_A_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0xbb, 0x79, 0x76, 0xb5, 0xb9, 0xe1, 0xa6, 0xaf, 0x08, 0x15,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length // data
	0xc7, 0x63, 0x80, 0x6e, 0xd7, 0x70, 0x7a, 0x11, 0xc4, 0x03, 0x1b, 0xa0, 0x70, 0x13, 0x7e, 0x69, // data 1-16
	0x69, 0x53, 0x33, 0x45, 0x92, 0xee, 0x3e, 0x09, 0xa4,
	
	// Encrypted data
	0xe6, 0x35, 0x83, 0xc4, 0x70, 0x40, 0xdf, 0x4f, 0x14, 0x77, 0x52, 0xb3, 0x4c, 0xf8, 0xca, 0xec,
	0x9f, 0xd7, 0x74, 0xe9, 0x03, 0x49, 0xe8, 0xcb, 0xef, 0xd8, 0xb3, 0x01, 0xfc, 0xe6, 0xe1, 0xd0,
	0x03, 0xbe, 0x61, 0x43, 0x2a, 0x66, 0xfb, 0x13, 0x3d, 0x67, 0xc5, 0x17, 0xd9, 0x53, 0x52, 0xbf,
	0xa8, 0x87, 0xe6, 0x20, 0x2d, 0xd1, 0xe9, 0xb8, 0x82, 0x29, 0xac, 0xb1, 0x93, 0x63, 0x10, 0xf2,
	0xa3, 0x7f, 0x60, 0x61, 0x31, 0xc3, 0x22, 0xa0, 0x7b, 0x88, 0x25, 0xf1, 0xbe, 0xee, 0x5b, 0x44,
	0x43, 0xab, 0xb9, 0x84, 0x58, 0xb4, 0xf4, 0xf3, 0xf6, 0x61, 0x81, 0x31, 0x04, 0x9c, 0xf5, 0xff,
	0xe2, 0x79, 0x65, 0x98, 0x6d, 0x1d, 0x4d, 0x00, 0xa8, 0x2d, 0x1d, 0x4f, 0xfd, 0x68, 0x7e, 0x7e,
	0xb3, 0x0f, 0xda, 0x4c, 0x90, 0xe9, 0x89, 0x64, 0x3d, 0xbe, 0xdf, 0xd3, 0x31, 0x2f, 0x1a, 0x96,
	0x89, 0xef, 0x00, 0x89, 0x7a, 0xe8, 0x56, 0xa1, 0x5a, 0x95, 0x66, 0xd4, 0x20, 0x0b, 0x20, 0xbc,
	0xe7, 0xe6, 0xea, 0x55, 0xdd, 0xd3, 0x33, 0x9c, 0x37, 0x82, 0xcb, 0xc1, 0x8d, 0x40, 0xf3, 0x0f,
	0x33, 0x13, 0x1f, 0xd4, 0x40, 0x65, 0xd1, 0x3f, 0xd1, 0xbb, 0xf6, 0x71, 0x88, 0xfc, 0x9c, 0xa4,
	0x8b, 0xbe, 0x41, 0xf6, 0x11, 0x0b, 0x09, 0x7f, 0x1d, 0x72, 0x04, 0x05, 0x4b, 0xaf, 0xe8, 0x0b,
	0x62, 0x7b, 0xce, 0xcf, 0x27, 0xd0, 0xb6, 0x19, 0x4a, 0x25, 0x94, 0x8f, 0x6a, 0x50, 0xa4, 0xec,
	0x30, 0x19, 0xda, 0x08, 0xc7, 0xa1, 0x90, 0x2e, 0x83, 0x44, 0x16, 0x49, 0x6b, 0x69, 0x6c, 0x63,
	0x17, 0x59, 0x28, 0xc9, 0xa9, 0x6f, 0xcb, 0xce, 0x22, 0x9f
};

std::vector<unsigned char> example_B_request = {
	0x01, 0x5d,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x3b, 0x6e, 0x32, 0x56, 0x72, 0x4d, 0x2a, 0x30,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x3d, 0x30, 0x00,
	
	// key_list: \hostname\gametype\gamever\hostport\timelimit\timeelapsed\mapname\numplayers\maxplayers\
	             teamplay\team_t\ping_\c0\c1\n0\n1\c0c\c1c\nr\xr\ff\mc\gc\rc\sr\ni\xi\qm
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x12, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_B_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0xe2, 0x7f, 0x2f, 0x6e, 0x42, 0x18, 0x35, 0x59, 0x19, 0x1b,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length
	0x7b, 0x7a, 0xbd, 0x2d, 0x2e, 0xb3, 0xa5, 0x7e, 0x9f, 0x91, 0x77, 0x74, 0xc0, 0xcd, 0x08, 0xf5, // data 1-16
	0x86, 0x60, 0xc0, 0xf5, 0x4c, 0xa2, 0x74, 0x7b, 0x10,                                           // data 17-25
	
	// Encrypted data
	0x46, 0xb5, 0xa5, 0x93, 0xf3, 0xaa, 0x48, 0xc4, 0x5e, 0xdb, 0x1a, 0x64, 0xf4, 0xee, 0x6f, 0x43,
	0xa7, 0x44, 0x73, 0x4b, 0x98, 0xa7, 0xe6, 0x96, 0xfb, 0x2f, 0xe4, 0xe2, 0xbd, 0xe6, 0x71, 0xae,
	0x7b, 0x76, 0xee, 0x99, 0x36, 0xef, 0x3b, 0x62, 0xfd, 0xd6, 0xbb, 0x55, 0x88, 0xb4, 0x43, 0xe1,
	0xd1, 0x85, 0x30, 0x2d, 0x45, 0xef, 0x08, 0x8f, 0x79, 0x6a, 0x78, 0xaf, 0x37, 0xe4, 0x79, 0x8d,
	0xa8, 0x1d, 0x1b, 0xa5, 0x5e, 0x9a, 0x03, 0xa2, 0x9a, 0xb3, 0xa2, 0x0d, 0xf8, 0xc9, 0xe3, 0xf1,
	0xce, 0xb3, 0x1d, 0x93, 0x6d, 0xc9, 0xf3, 0x25, 0x99, 0xb8, 0x77, 0xfb, 0xd4, 0x6b, 0x7b, 0x2c,
	0x3c, 0xa3, 0xe0, 0x19, 0x8b, 0x6f, 0x2a, 0x79, 0xa7, 0x54, 0xc0, 0x9f, 0xa9, 0x7e, 0xea, 0x90,
	0xe1, 0xd1, 0x22, 0x5c, 0x8f, 0x8a, 0x87, 0x76, 0x5c, 0x21, 0x01, 0x5c, 0x35, 0x0f, 0x20, 0xe4,
	0x8b, 0x7f, 0xfc, 0x0f, 0xec, 0x32, 0x5a, 0x2c, 0xbd, 0x61, 0xdd, 0x11, 0xc6, 0x75, 0x21, 0x62,
	0x89, 0x05, 0x6c, 0x0a, 0xc2, 0xf3, 0xfd, 0xfe, 0x73, 0xea, 0x41, 0x44, 0xb6, 0xb6, 0x1e, 0x2d,
	0x15, 0x24, 0xf4, 0x64, 0x9c, 0x41, 0x06, 0x3f, 0xa8, 0xf8, 0x49, 0x3f, 0x63, 0x2f, 0xe0, 0x74,
	0x31, 0xe8, 0x43, 0xa0, 0x23, 0x3d, 0xae, 0x4d, 0x5e, 0x95, 0xcf, 0xcd, 0x83, 0x3d, 0x25, 0xbd,
	0x22, 0xaf, 0x72, 0x39, 0xc3, 0xea, 0x94, 0x72
};

std::vector<unsigned char> example_C_request = {
	0x01, 0x5e,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x34, 0x68, 0x6b, 0x54, 0x61, 0x5c, 0x2d, 0x6d,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)!=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x21, 0x3d, 0x30, 0x00,
	
	// key_list: \hostname\gametype\gamever\hostport\timelimit\timeelapsed\mapname\numplayers\maxplayers\
	             teamplay\team_t\ping_\c0\c1\n0\n1\c0c\c1c\nr\xr\ff\mc\gc\rc\sr\ni\xi\qm
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x14, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_C_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0x48, 0x3c, 0xdb, 0xb6, 0x0b, 0x68, 0x4f, 0x45, 0xb1, 0xcd,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length
	0x8e, 0x71, 0x43, 0xfa, 0xdb, 0x0c, 0x42, 0xef, 0xaf, 0x68, 0xfb, 0x64, 0x4b, 0x53, 0xac, 0x69, // data 1-16
	0xbf, 0x74, 0xe8, 0x4d, 0x6f, 0x30, 0x8a, 0x4a, 0xe6,                                           // data 17-25
	
	// Encrypted data
	0x92, 0xbd, 0x4c, 0xaf, 0x27, 0x6d, 0x87, 0x87, 0x3a, 0xfa, 0x44, 0x67, 0x16, 0xbc, 0x8e, 0x2e,
	0xe0, 0x9f, 0xfb, 0x0d, 0xdf, 0x37, 0x5b, 0xe4, 0x8a, 0xc4, 0x06, 0x21, 0x7d, 0x55, 0x73, 0xfe,
	0x5b, 0x22, 0x23, 0xd9, 0x9e, 0xd2, 0xe3, 0xbd, 0xd9, 0xd2, 0xcd, 0x2c, 0x6b, 0xc6, 0x2a, 0xe0,
	0x34, 0x7b, 0xfd, 0x6a, 0xed, 0xad, 0xcf, 0xca, 0x88, 0x5e, 0xa3, 0x9e, 0xef, 0xc4, 0x0f, 0x95,
	0x84, 0xf4, 0xaa, 0xd7, 0x04, 0x03, 0xfd, 0xfd, 0x0e, 0xc9, 0xd3, 0xeb, 0x78, 0x0c, 0x39, 0xc7,
	0xbb, 0xe8, 0xa3, 0x8a, 0x49, 0x31, 0xb1, 0xe1, 0xde, 0x74, 0x40, 0x48, 0x37, 0x45, 0x1a, 0x4f,
	0xb3, 0x3a, 0xc8, 0x2c, 0x5d, 0x22, 0xd3, 0x59, 0xb1, 0x40, 0x54, 0x21, 0xdd, 0x20, 0xa4, 0x89,
	0x26, 0xfc, 0x2c, 0x45, 0x12, 0x7e, 0x0e, 0x67, 0xc9, 0x53, 0xb2, 0x05, 0xa6, 0xbc, 0x74, 0xba,
	0x63, 0x21, 0x82, 0x49, 0x68, 0xd7, 0x26, 0x39, 0xc3, 0xdc, 0x56, 0xee, 0x36, 0x24, 0xd6, 0x93,
	0x83, 0xe6, 0x8a, 0x84, 0x53, 0x00, 0x80, 0xb9, 0x5c, 0x19, 0xf4, 0xa6, 0x54, 0xc3, 0xc0, 0xa4,
	0x1a, 0x0b, 0x03, 0x32, 0xb2, 0x5f, 0x6f, 0x83, 0xef, 0x38, 0xed, 0x5a, 0x39, 0xa2, 0xbe, 0x0d,
	0x8b, 0xa8, 0x14, 0xaf, 0xaa, 0x8f, 0x3a, 0x37, 0xc5, 0xab, 0x0a, 0x01, 0x8a, 0x67, 0xc2, 0x62,
	0xac, 0x53, 0x19, 0xd1, 0x51, 0xa2, 0x81, 0x05, 0xc3, 0x6a, 0xde, 0x17, 0xb3, 0x4a, 0x5d, 0xc2,
	0xb4, 0xe6, 0x91, 0x02, 0x4a, 0x0b, 0x75, 0x70, 0x86, 0xe1, 0xe8, 0x93, 0x3f, 0x7c, 0x5a, 0xc8,
	0x55, 0xd7, 0x04, 0x7a, 0x7a, 0x46, 0x4f, 0x5d, 0x88, 0x13
};

std::vector<unsigned char> example_D_request = {
	0x01, 0x5d,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x25, 0x70, 0x24, 0x56, 0x7c, 0x29, 0x3e, 0x5d,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x3d, 0x30, 0x00,
	
	// key_list
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x12, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_D_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0x48, 0x3c, 0xdb, 0xb6, 0x0b, 0x68, 0x4f, 0x45, 0xb1, 0xcd,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length
	0x8e, 0x71, 0x43, 0xfa, 0xdb, 0x0c, 0x42, 0xef, 0xaf, 0x68, 0xfb, 0x64, 0x4b, 0x53, 0xac, 0x69, // data 1-16
	0xbf, 0x74, 0xe8, 0x4d, 0x6f, 0x30, 0x8a, 0x4a, 0xe6,                                           // data 17-25
	
	// Encrypted data
	0xa6, 0x4e, 0x0e, 0xe7, 0xbc, 0xdf, 0xa6, 0xc1, 0x47, 0x28, 0x28, 0x44, 0xeb, 0x9e, 0xac, 0x94,
	0x71, 0x36, 0xcf, 0xed, 0x49, 0x98, 0x2d, 0xa9, 0x44, 0xbf, 0xe6, 0xc2, 0x6d, 0xa9, 0x15, 0x00,
	0x83, 0xa6, 0x30, 0xe6, 0x63, 0x9a, 0xcb, 0x85, 0x91, 0xad, 0xfe, 0x22, 0x1b, 0xac, 0x27, 0xe4,
	0xee, 0x4a, 0xe6, 0x31, 0x03, 0x18, 0x30, 0x31, 0x2b, 0xb5, 0xca, 0x60, 0xd7, 0xc6, 0x64, 0x25,
	0x0c, 0x20, 0x08, 0x47, 0x95, 0x50, 0x98, 0xb5, 0xd3, 0xa8, 0x6c, 0x4d, 0x1e, 0x27, 0x43, 0xc0,
	0x8e, 0xf3, 0x9d, 0xfd, 0x83, 0xb6, 0x4d, 0x4c, 0x6b, 0x39, 0x72, 0x0d, 0x1a, 0x97, 0x55, 0x4c,
	0x7f, 0xe5, 0xf4, 0x32, 0x82, 0xd4, 0x29, 0xe1, 0x29, 0x4a, 0x4a, 0x68, 0x28, 0x62, 0xe6, 0xbe,
	0xed, 0xfa, 0xd2, 0x63, 0xc1, 0x1d, 0x54, 0xaf, 0xcc, 0x68, 0x11, 0x1e, 0x3e, 0xda, 0xb3, 0x65,
	0x9f, 0x1a, 0x61, 0x99, 0xcd, 0x3d, 0x2f, 0x47, 0xaf, 0xdb, 0x52, 0xb4, 0xa2, 0x62, 0xd5, 0xee,
	0x5b, 0xb1, 0x32, 0xd9, 0xea, 0x82, 0xac, 0x43, 0xab, 0x5c, 0x77, 0xd9, 0xab, 0x4b, 0xf0, 0x07,
	0x58, 0x6f, 0x9d, 0xf3, 0x64, 0xd2, 0x37, 0x8d, 0x2e, 0x72, 0x45, 0x84, 0x89, 0x18, 0x98, 0x9c,
	0x13, 0x7e, 0x1a, 0x89, 0x29, 0x6b, 0x5b, 0x0b, 0x08, 0x0b, 0x7f, 0x11, 0x41, 0x50, 0x1e, 0x55,
	0x6e, 0xa9, 0x13, 0x99, 0x88, 0xcc, 0xf0, 0x76
};

std::vector<unsigned char> example_C_decrypt_data = {
	// Request
	0x56, 0x57, 0x8b, 0xeb,                                                       // Request ip: 86.87.139.235
	0x19, 0x64,                                                                   // Requested: port 6500

	// Accepted server values
	0x1c, 0x00,                                                                   // Total header items: 28
	0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                   // hostname
	0x67, 0x61, 0x6d, 0x65, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00,                   // gametype
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x00, 0x00,                         // gamever
	0x68, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x72, 0x74, 0x00, 0x00,                   // hostport
	0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x00, 0x00,             // timelimit
	0x74, 0x69, 0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x00, 0x00, // timeelapsed
	0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                         // mapname
	0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // numplayers
	0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // maxplayers
	0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x00, 0x00,                   // teamplay
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x00, 0x00,                               // team_t
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x00, 0x00,                                     // ping_
	0x63, 0x30, 0x00, 0x00,                                                       // c0
	0x63, 0x31, 0x00, 0x00,                                                       // c1
	0x6e, 0x30, 0x00, 0x00,                                                       // n0
	0x6e, 0x31, 0x00, 0x00,                                                       // n1
	0x63, 0x30, 0x63, 0x00, 0x00,                                                 // c0c
	0x63, 0x31, 0x63, 0x00, 0x00,                                                 // c1c
	0x6e, 0x72, 0x00, 0x00,                                                       // nr
	0x78, 0x72, 0x00, 0x00,                                                       // xr
	0x66, 0x66, 0x00, 0x00,                                                       // ff
	0x6d, 0x63, 0x00, 0x00,                                                       // mc
	0x67, 0x63, 0x00, 0x00,                                                       // gc
	0x72, 0x63, 0x00, 0x00,                                                       // rc
	0x73, 0x72, 0x00, 0x00,                                                       // sr
	0x6e, 0x69, 0x00, 0x00,                                                       // ni
	0x78, 0x69, 0x00, 0x00,                                                       // xi
	0x71, 0x6d, 0x00, 0x00,                                                       // qm

	// New server
	0x3b,                            // flags: FLAG_UNSOLICITED_UDP | FLAG_PRIVATE_IP | FLAG_ICMP_IP |
	                                 //        FLAG_NONSTANDARD_PORT | FLAG_NONSTANDARD_PRIVATE_PORT
	0xa8, 0x77, 0xbd, 0x95,          //                                  wan ip:      168.119.189.149
	0x0e, 0x4a,                      // FLAG_NONSTANDARD_PORT         -> wan port:    3658
	0xa8, 0x77, 0xbd, 0x95,          // FLAG_PRIVATE_IP               -> localip0 ip: 168.119.189.149
	0x0e, 0x4a,                      // FLAG_NONSTANDARD_PRIVATE_PORT -> localport:   3658
	0xa8, 0x77, 0xbd, 0x95,          // FLAG_ICMP_IP                  -> icmp ip:     168.119.189.149

	// New server
	0x3b,                            // flags: FLAG_UNSOLICITED_UDP | FLAG_PRIVATE_IP | FLAG_ICMP_IP |
	                                 //        FLAG_NONSTANDARD_PORT | FLAG_NONSTANDARD_PRIVATE_PORT
	0x4e, 0x2f, 0xb8, 0x17,          //                                  wan ip:      78.47.184.23
	0x0e, 0x4a,                      // FLAG_NONSTANDARD_PORT         -> wan port:    3658
	0x4e, 0x2f, 0xb8, 0x17,          // FLAG_PRIVATE_IP               -> localip0 ip: 78.47.184.23
	0x0e, 0x4a,                      // FLAG_NONSTANDARD_PRIVATE_PORT -> localport:   3658
	0x4e, 0x2f, 0xb8, 0x17,          // FLAG_ICMP_IP                  -> icmp ip:     78.47.184.23
	
	// No more server information
	0x00,
	
	// End decrypted data
	0xff, 0xff, 0xff, 0xff
};

std::vector<unsigned char> example_D_decrypt_data = {
	// Request
	0x56, 0x57, 0x8b, 0xeb,                                                       // Request ip: 86.87.139.235
	0x19, 0x64,                                                                   // Requested: port 6500
	
	// Accepted server values
	0x1c, 0x00,                                                                   // Total header items: 28
	0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                   // hostname
	0x67, 0x61, 0x6d, 0x65, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00,                   // gametype
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x00, 0x00,                         // gamever
	0x68, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x72, 0x74, 0x00, 0x00,                   // hostport
	0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x00, 0x00,             // timelimit
	0x74, 0x69, 0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x00, 0x00, // timeelapsed
	0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                         // mapname
	0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // numplayers
	0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // maxplayers
	0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x00, 0x00,                   // teamplay
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x00, 0x00,                               // team_t
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x00, 0x00,                                     // ping_
	0x63, 0x30, 0x00, 0x00,                                                       // c0
	0x63, 0x31, 0x00, 0x00,                                                       // c1
	0x6e, 0x30, 0x00, 0x00,                                                       // n0
	0x6e, 0x31, 0x00, 0x00,                                                       // n1
	0x63, 0x30, 0x63, 0x00, 0x00,                                                 // c0c
	0x63, 0x31, 0x63, 0x00, 0x00,                                                 // c1c
	0x6e, 0x72, 0x00, 0x00,                                                       // nr
	0x78, 0x72, 0x00, 0x00,                                                       // xr
	0x66, 0x66, 0x00, 0x00,                                                       // ff
	0x6d, 0x63, 0x00, 0x00,                                                       // mc
	0x67, 0x63, 0x00, 0x00,                                                       // gc
	0x72, 0x63, 0x00, 0x00,                                                       // rc
	0x73, 0x72, 0x00, 0x00,                                                       // sr
	0x6e, 0x69, 0x00, 0x00,                                                       // ni
	0x78, 0x69, 0x00, 0x00,                                                       // xi
	0x71, 0x6d, 0x00, 0x00,                                                       // qm
	
	// No more server information
	0x00, 
	
	// End decrypted data
	0xff, 0xff, 0xff, 0xff
};

std::vector<unsigned char> example_E_request = {
	0x00, 0x33,                                                                                    // Total Bytes to read
	0x00,                                                                                          // 
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x66, 0x59, 0x35, 0x70, 0x68, 0x39, 0x33, 0x3a,
	
	// ????
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

std::vector<unsigned char> example_E_response = {
	// Crypt challenge
	0xe6,
	0xff, 0x1c, 0xf3, 0x4c, 0x8d, 0xc4, 0x5a, 0x52, 0x2b, 0x58,
	
	// Server challenge
	0xf3,
	0x28, 0x00, 0x41, 0xbd, 0x53, 0xd3, 0x37, 0x96, 0x63, 0xf3, 0xd3, 0x0c, 0xe6, 0x16, 0xa6, 0x39,
	0x0b, 0x2e, 0x27, 0x1d, 0xd8, 0x26, 0x39, 0xcb, 0x72,
	
	// Encrypted data
	0x34, 0x13, 0xba, 0x57, 0xd7, 0xf2,
	
	// Encrypted data in second packet
	0x43, 0x1b, 0xcd, 0xae, 0xe3, 0x3d, 0xfa, 0x71, 0x63, 0xb0, 0x00, 0xda, 0x5c, 0xb5, 0x4b, 0x92,
	0xeb, 0x79, 0x44, 0x21, 0xd0, 0x41, 0x28, 0x78, 0x8c, 0x06, 0x5c, 0x95, 0x38, 0xa2, 0x7a, 0x8d,
	0x91, 0xbb, 0x2c, 0xdb, 0x47, 0x62, 0x03, 0x43, 0x82, 0xf5, 0xe1, 0x38, 0xb3, 0xe5, 0xcd, 0xdb,
	0x0f, 0xe2, 0x52, 0x5c, 0xd9, 0x84, 0xce, 0xc1, 0x60, 0x5e, 0x96, 0x4a, 0x1a, 0x54, 0xc1, 0xed,
	0xfd, 0x8e, 0x5b, 0xce, 0x73, 0xdd, 0xe1, 0x46, 0xc4, 0x72, 0x0c, 0xd1, 0xd3, 0x7d, 0xb1, 0x7c,
	0x1a, 0x1c, 0x5c, 0x90, 0x5a, 0x03, 0x8c, 0x26, 0x2f, 0xb7, 0x4a, 0x3e, 0x39, 0x65, 0xa6, 0x62,
	0x07, 0x58, 0x02, 0x46, 0x26, 0x03, 0x75, 0x74, 0xc0, 0x74, 0x0b, 0xde, 0x82, 0x84, 0x3c, 0x61,
	0x05, 0x75, 0x9b, 0x70, 0x8d, 0xf6, 0x53, 0x47, 0x53, 0x05, 0x23, 0x1d, 0xa0, 0x2d, 0x8e, 0xf9,
	0xf3, 0x33, 0x5d, 0x44, 0xbd, 0xaa, 0x8c, 0xcc, 0xbb, 0x74, 0xa7, 0x5c, 0x53, 0x66, 0xfc, 0x8e,
	0x72, 0x19, 0xef, 0x1e, 0xb4, 0x44, 0x35, 0xe6, 0x98, 0x5a, 0xac, 0xb8, 0xdb, 0x97, 0xeb, 0xd1,
	0x8d, 0x64, 0xcd, 0x79, 0x07, 0x41, 0x9a, 0x40, 0x7e, 0xb0, 0x3b, 0xdd, 0xb8, 0x0d, 0xcc, 0xe0,
	0xda, 0xc0, 0xc9, 0x7a, 0xea, 0x5c, 0xc9, 0x11, 0xb5, 0xad, 0xb9, 0x80, 0x75, 0xd9, 0x98, 0xf9,
	0x73, 0x40, 0xcc, 0xcc, 0xe0, 0x77, 0xf1, 0xc3, 0xbc, 0x9b, 0xa1, 0x9d, 0x95, 0x21, 0x6c, 0x83,
	0x39, 0x97, 0x37, 0x7d, 0x87, 0x33, 0xab, 0x72, 0xf6, 0x7a, 0x70, 0xff, 0x5d, 0xbf, 0xae, 0xd2,
	0x71, 0x2c, 0x01, 0x4e, 0x76, 0x3b, 0x32, 0x64, 0x80, 0x40, 0xd4, 0x4a, 0xd7, 0x53, 0x2b, 0x81,
	0x14, 0xf5, 0xdf, 0xd0, 0x77, 0x51, 0x71, 0xd3, 0x35, 0x4a, 0x0a, 0xa1, 0x00, 0xcf, 0xec, 0x59,
	0x4e, 0x08, 0xda, 0x86, 0xdd, 0x0d, 0xc8, 0x8a, 0xd6, 0x4a, 0xf6, 0x49, 0xe3, 0xba, 0xbb, 0xac,
	0x1e, 0xd4, 0x48, 0xa4, 0xa5, 0xfb, 0x39, 0x95, 0x37, 0x49, 0x1c, 0x55, 0xa5, 0x87, 0x97, 0x74,
	0x1b, 0x63, 0xc4, 0x6c, 0x31, 0xe0, 0xb3, 0x55, 0x4a, 0x85, 0xd2, 0x91, 0x4d, 0x77, 0xc4, 0x25,
	0xd1, 0x6c, 0xd2, 0xc7, 0xcf, 0x1c, 0x39, 0x0d, 0xa6, 0x93, 0x9c, 0x71, 0x95, 0xe1, 0x9f, 0x58,
	0x4a, 0x6a, 0x06, 0x0f, 0xbe, 0x2b, 0x6c, 0x0b, 0x39, 0x03, 0xca, 0xac, 0x95, 0xb7, 0x3a, 0xc6,
	0xaa, 0x88, 0xa0, 0x6d, 0x22, 0xd6, 0x24, 0x39, 0xef, 0x8a, 0x54, 0x3b, 0x86, 0xe0, 0xc7, 0x5f,
	0x46, 0xfe, 0x74, 0x02, 0x10, 0x3a, 0x07, 0x90, 0x41, 0x0b, 0xa0, 0x28, 0xea, 0x52, 0xdb, 0x12,
	0xee, 0xed, 0xe1, 0xf3, 0x1c, 0x88, 0x56, 0x54, 0xa2, 0x1a, 0xf4, 0x58, 0xd0, 0xee, 0xb5, 0x79,
	0x5d, 0x62, 0x91, 0x03, 0xfd, 0xd4, 0xc4, 0xe6, 0x51, 0x2b, 0x61, 0x9a, 0xd4, 0xe8, 0x0f, 0x5a,
	0xaf, 0x38, 0x7a, 0x0c, 0xfa, 0x73, 0x8e, 0xb6, 0xe2, 0xa6, 0x55, 0xd0, 0x4e, 0xbb, 0x84, 0x8b,
	0x7c, 0xc7, 0xc8, 0x9f, 0x47, 0xe7, 0x51, 0xe3, 0xfe, 0x87, 0x4c, 0x06, 0x3c, 0xfc, 0x07, 0x8d,
	0x3d, 0x5d, 0xc2, 0x54, 0xe8, 0xba, 0x76, 0x54, 0x2d, 0x7f, 0x11, 0x2f, 0x27, 0x05, 0x79, 0x4a,
	0xf7, 0x3c, 0xdc, 0xcf, 0x09, 0x31, 0x6b, 0xb1, 0x66, 0x2d, 0x46, 0x99, 0x25, 0x52, 0xbe, 0x4e,
	0x60, 0x57, 0xb5, 0x19, 0xf1, 0x3d, 0x37, 0xb5, 0x29, 0x18, 0x7e, 0x0b, 0x9c, 0x14, 0x26, 0x91,
	0xa9, 0x98, 0xea, 0x75, 0xe5, 0x8a, 0x91, 0x73, 0xf0, 0xe4, 0x85, 0xc4, 0xaa, 0x4a, 0xec, 0x43,
	0xaf, 0x8b, 0x95, 0xfe, 0xe0, 0xdd, 0xfd, 0xf4, 0x2f, 0x8c, 0x8d, 0x5b, 0x26, 0x0c, 0x6d, 0x30,
	0x04, 0xcf, 0x89, 0x30, 0x69, 0x70, 0xbf, 0xbc, 0x62, 0x2f, 0x52, 0xe3, 0x23, 0x04, 0x11, 0x22,
	0xbe, 0x6f, 0xda, 0x91, 0xdb, 0x72, 0x6b, 0x21, 0x63, 0x0d, 0x43, 0x1f, 0x2b, 0xbf, 0xba, 0xd7,
	0x65, 0xbb, 0x05, 0x59, 0x80, 0xe6, 0xc4, 0xda, 0x64, 0x44, 0x86, 0x90, 0x49, 0xd4, 0x4b, 0x74,
	0x5f, 0x1a, 0x31, 0xb4, 0x62, 0x88, 0x93, 0x0c, 0x01, 0x25, 0x03, 0x2a, 0x7b, 0x42, 0xba, 0x7d,
	0x7e, 0xfb, 0x0b, 0x3b, 0x5d, 0x25, 0x04, 0x14, 0x4c, 0x6b, 0x68, 0xee, 0x52, 0x05, 0x9b, 0xe8,
	0x3c, 0xc6, 0xa2, 0x48, 0x14, 0x89, 0xe9, 0x1e, 0xc3, 0x64, 0xe4, 0x0a, 0xc7, 0x64, 0xb4, 0xb9,
	0x3e, 0xcd, 0x37, 0xb1, 0x25, 0xae, 0x51, 0x13, 0x6a, 0xd1, 0xf4, 0xb1, 0x48, 0x9f, 0x67, 0x60,
	0x3f, 0x06, 0x19, 0x7f, 0x23, 0x68, 0x29, 0x94, 0x0f, 0x1c, 0x4b, 0x2f, 0x30, 0xb5, 0x7f, 0x2c,
	0x2f, 0x3d, 0x0f, 0xa1, 0xc6, 0x78, 0xab, 0xae, 0xa1, 0xfa, 0xff, 0xd3, 0x1f, 0x96, 0xd9, 0x17,
	0x00, 0x9f, 0xdc, 0xa6, 0xd1, 0x1e, 0x0f, 0xee, 0xbe, 0xab, 0xa5, 0xd4, 0xf0, 0x4d, 0xb8, 0xd6,
	0x88, 0x32, 0x7f, 0xc5, 0x44, 0x3e, 0x6c, 0x31, 0xfa, 0xb2, 0x4a, 0xc7, 0x9c, 0xc0, 0x0e, 0x10,
	0xdb, 0xaf, 0x72, 0x1f, 0x82, 0x6b, 0xbf, 0xdd, 0xd0, 0xdd, 0x43, 0x88, 0xc0, 0x47, 0xae, 0xfe,
	0x12, 0x19, 0x45, 0x80, 0x68, 0x24, 0x13, 0xf6, 0xc9, 0x8c, 0xd7, 0x51, 0xf9, 0x60, 0x46, 0xcd,
	0xb5, 0x95, 0xb5, 0x75, 0xa1, 0xba, 0xfa, 0xe1, 0x64, 0xc8, 0x42, 0x58, 0x7a, 0x19, 0xfa, 0x9d,
	0x01, 0x57, 0xbc, 0xfa, 0xa3, 0x64, 0x89, 0xad, 0xbd, 0x4e, 0xba, 0x03, 0x08, 0xb4, 0xe5, 0x8f,
	0xec, 0x61, 0x5a, 0x69, 0x71, 0xab, 0xa9, 0x49, 0x8b, 0xb8, 0x32, 0xae, 0xcb, 0x23, 0x8c, 0xd8,
	0xff, 0xfe, 0xc7, 0xf9, 0xe1, 0x7e, 0x96, 0x72, 0x02, 0x44, 0x76, 0x60, 0x26, 0xa3, 0xf5, 0xe9,
	0x79, 0x8f, 0xd0, 0xaf, 0xf3, 0x7a, 0xca, 0x2a, 0x28, 0xef, 0xe8, 0xe3, 0x77, 0xe0, 0xaf, 0x8e,
	0x97, 0x34, 0x17, 0x00, 0xbf, 0x20, 0xcb, 0xa5, 0xff, 0x4a, 0xb0, 0x8d, 0xbd, 0xa5, 0x7c, 0x10,
	0xde, 0xf0, 0x42, 0x64, 0x55, 0x1b, 0x62, 0x47, 0xce, 0x58, 0xf0, 0x8c, 0xcc, 0x44, 0x9c, 0xbb,
	0x84, 0xfb, 0xe6, 0x2d, 0x20, 0x2f, 0xb2, 0xbd, 0xd0, 0x52, 0x57, 0xfa, 0x93, 0x2a, 0xd5, 0xd6,
	0x15, 0x4b, 0xee, 0x1a, 0x82, 0x7f, 0xb4, 0x84, 0x89, 0x86, 0x2e, 0xdb, 0x1a, 0x75, 0x3b, 0x62,
	0x14, 0xdc, 0x73, 0x9f, 0x16, 0xd2, 0xa0, 0x98, 0x1e, 0xe1, 0xdd, 0xb3, 0xa3, 0x77, 0xb4, 0x1d,
	0x21, 0x3a, 0xe9, 0x07, 0xcd, 0x36, 0x97, 0xda, 0x9c, 0xde, 0x8c, 0xc7, 0xb6, 0xe3, 0xcd, 0x34,
	0xcf, 0x6f, 0x1b, 0x3d, 0xca, 0xd8, 0x47, 0x6a, 0x9f, 0x0a, 0xfd, 0x42, 0xf6, 0x25, 0xcd, 0x62,
	0x54, 0x19, 0x80, 0xb7, 0x39, 0x2b, 0xe1, 0xde, 0xcc, 0x09, 0x23, 0x7f, 0x71, 0xc1, 0x20, 0xa1,
	0x88, 0x43, 0x6f, 0xb5, 0x50, 0xe3, 0x65, 0x87, 0x71, 0xce, 0xdd, 0x5d, 0x6f, 0xf1, 0x74, 0xb8,
	0xdc, 0x34, 0xb7, 0x14, 0x12, 0x85, 0x90, 0x22, 0xbc, 0x1a, 0x27, 0x98, 0x17, 0x60, 0x71, 0x8f,
	0x3f, 0x3e, 0x47, 0x98, 0x09, 0xaa, 0xfd, 0x96, 0xc3, 0xac, 0xda, 0x58, 0xcd, 0x40, 0xd4, 0x29,
	0x6d, 0x75, 0xf9, 0x93, 0xb7, 0x12, 0x99, 0x5b, 0x6e, 0xee, 0xb9, 0x06, 0x11, 0x57, 0xc4, 0x7e,
	0x86, 0xda, 0x48, 0x55, 0x6d, 0xa5, 0x0e, 0x4c, 0xe8, 0xdf, 0x14, 0x48, 0xbe, 0xa0, 0xa8, 0xc0,
	0x56, 0x0f, 0x38, 0x7b, 0x55, 0x99, 0x32, 0xd4, 0x9a, 0xab, 0x8f, 0x1a, 0xcc, 0x1b, 0x0a, 0xfb,
	0x4b, 0xde, 0x05, 0x5b, 0xb9, 0x1d, 0x1c, 0x11, 0xa7, 0x5f, 0x5d, 0x76, 0xd7, 0x56, 0xe1, 0x71,
	0x0d, 0x3c, 0xa7, 0x2d, 0xa4, 0xde, 0xa7, 0x11, 0x3f, 0x1c, 0xb7, 0x67, 0x40, 0x64, 0xe5, 0xc5,
	0x71, 0xec, 0x19, 0xf0, 0xd8, 0x33, 0xca, 0xe5, 0xf9, 0x95, 0x47, 0xaa, 0x10, 0x72, 0x48, 0x9f,
	0x8d, 0xf2, 0xef, 0x79, 0x09, 0xc5, 0xae, 0x71, 0x5a, 0x4d, 0x53, 0x11, 0x93, 0x0c, 0x74, 0xec,
	0xd5, 0x08, 0x98, 0x25, 0x97, 0x99, 0x1a, 0xd5, 0x98, 0x5e, 0xe8, 0x23, 0xbe, 0x5d, 0x31, 0xc8,
	0x6a, 0x2b, 0x77, 0x8c, 0x23, 0xc9, 0x63, 0x9a, 0x99, 0x4f, 0x08, 0xb8, 0xdb, 0x13, 0xd6, 0x89,
	0xb0, 0xe0, 0x55, 0xa1, 0xa9, 0xb4, 0x0c, 0xa5, 0x3a, 0xcf, 0x78, 0xd0, 0xcb, 0x00, 0xad, 0xcd,
	0x6c, 0x28, 0x6f, 0xd0, 0xaa, 0x28, 0x42, 0xc7, 0x9e, 0x28, 0x67, 0xf6, 0xbe, 0x51, 0x2a, 0xcf,
	0x6a, 0x3d, 0x06, 0x88, 0xf8, 0x7b, 0x32, 0x21, 0xe3, 0xeb, 0x34, 0xfe, 0x19, 0x5d, 0xd4, 0xcf,
	0x5d, 0x55, 0x99, 0x67, 0x0a, 0x59, 0x40, 0x10, 0xfc, 0xd8, 0x47, 0x39, 0xe5, 0x14, 0x37, 0x72,
	0x82, 0xc1, 0x25, 0xf1, 0x61, 0x56, 0xb2, 0x83, 0xc0, 0xa7, 0x56, 0x90, 0x89, 0x60, 0x42, 0xea,
	0x77, 0xcc, 0x79, 0xb3, 0x52, 0xca, 0x6c, 0xd2, 0xdb, 0x91, 0x15, 0x6c, 0x50, 0x3a, 0xa9, 0xa7,
	0x08, 0x54, 0xdc, 0x5e, 0xac, 0xbb, 0x3e, 0x30, 0x4f, 0xf9, 0xe2, 0xac, 0x1e, 0xe7, 0xef, 0xfc,
	0xa9, 0x90, 0x2d, 0x22, 0x06, 0x4c, 0x98, 0x08, 0x54, 0x12, 0x5a, 0xbc, 0x7c, 0xe7, 0x60, 0x5e,
	0xdd, 0xae, 0x2d, 0xc9, 0x94, 0x8c, 0xd0, 0x31, 0xbc, 0x5d, 0x77, 0xf3, 0xac, 0x68, 0x7e, 0x16,
	0xd3, 0xfe, 0x40, 0x62, 0xb9, 0xff, 0x62, 0x3c, 0xcc, 0xbd, 0x0a, 0xfb, 0xb1, 0x26, 0x0a, 0x88,
	0xc1, 0x2c, 0xfb, 0x5e, 0xc6, 0xfc, 0x96, 0x83, 0xda, 0x37, 0x8c, 0xe4, 0x42, 0xe3, 0xcd, 0xdb,
	0x2a, 0x2d, 0x27, 0x75, 0x0a, 0x58, 0x6e, 0x5a, 0x12, 0xb9, 0xd9, 0x55, 0xf0, 0xf7, 0xbb, 0x71,
	0x6c, 0xa6, 0x50, 0xa3, 0xed, 0x39, 0xcf, 0xb1, 0x16, 0x2e, 0x3b, 0x47, 0x4e, 0xb7, 0x7b, 0x5c,
	0x6b, 0x50, 0x42, 0xf9, 0x3e, 0x2e, 0x8e, 0xe8, 0xa5, 0xa0, 0xb6, 0xe0, 0x4a, 0xc2, 0x6f, 0xcf,
	0x24, 0x5e, 0xfe, 0x43, 0xbf, 0x15, 0x38, 0x74, 0x6e, 0x23, 0x67, 0xe5, 0xd3, 0x03, 0x07, 0xa1,
	0xc8, 0x19, 0x65, 0x2c, 0x4b, 0xf5, 0x1f, 0xd2, 0x65, 0xd8, 0x82, 0x05, 0x1a, 0x85, 0x6b, 0x3a,
	0x7f, 0x3b, 0x23, 0x9e, 0x82, 0x07, 0xb8, 0xac, 0x87, 0x54, 0xf4, 0xc6, 0x45, 0x32, 0x0c, 0xf8,
	0xe3, 0xe4, 0x1f, 0x86, 0x49, 0xd2, 0x04, 0xdb, 0x2e, 0xc8, 0x27, 0x5e, 0xf2, 0xfa, 0x7d, 0xa3,
	0x20, 0x0b, 0x40, 0xe6, 0x9b, 0x1c, 0x31, 0xb4, 0x79, 0xf3, 0x5e, 0x61, 0xd6, 0x8c, 0x3f, 0x27,
	0xd0, 0x0e, 0xcf, 0x6f, 0x9f, 0x76, 0xe0, 0x12, 0x25, 0xe2, 0xac, 0x1a, 0xf5, 0x24, 0x5f, 0x73,
	0x18, 0x10, 0xe1, 0x25, 0x05, 0xbc, 0xda, 0x2f
};

std::vector<unsigned char> example_E_decrypt_data = {
	// Request 
	0x56, 0x57, 0x8b, 0xeb,                                                       // Request ip: 86.87.139.235
	0x19, 0x64,                                                                   // Requested: port 6500
	
	0x05, 0xa8,                                                                   // Total Bytes to read
	0x02,                                                                         // ???
	
	// Server information
	0xbb,                    // flags: FLAG_UNSOLICITED_UDP | FLAG_PRIVATE_IP | FLAG_ICMP_IP |
	                         //        FLAG_NONSTANDARD_PORT | FLAG_NONSTANDARD_PRIVATE_PORT |
	                         //        FLAG_HAS_FULL_RULES
	0x4e, 0x2f, 0xb8, 0x17,  //                                  wan ip:      78.47.184.23
	0x0e, 0x4a,              // FLAG_NONSTANDARD_PORT         -> wan port:    3658
	0x4e, 0x2f, 0xb8, 0x17,  // FLAG_PRIVATE_IP               -> localip0 ip: 78.47.184.23
	0x0e, 0x4a,              // FLAG_NONSTANDARD_PRIVATE_PORT -> localport:   3658
	0x4e, 0x2f, 0xb8, 0x17,  // FLAG_ICMP_IP                  -> icmp ip:     78.47.184.23
	
	// backend_id = bfield1942ps2:1508534:
	0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x5f, 0x69, 0x64, 0x00,
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x3a,	0x31, 0x35,
	0x30, 0x38, 0x35, 0x33, 0x34, 0x3a, 0x00,
	
	// cl = 100.216335.alpha
	0x63, 0x6c, 0x00,
	0x31, 0x30, 0x30, 0x2e, 0x32, 0x31, 0x36, 0x33, 0x33, 0x35, 0x2e, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x00,
	
	// country = DE
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x00,
	0x44, 0x45, 0x00,
	
	// ff = 1
	0x66, 0x66, 0x00,
	0x31, 0x00,
	
	// fraglimit = 0
	0x66, 0x72, 0x61, 0x67, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x00, 
	0x30, 0x00,
	
	// gamemode = openplaying
	0x67, 0x61, 0x6d, 0x65, 0x6d, 0x6f, 0x64, 0x65, 0x00,
	0x6f, 0x70, 0x65, 0x6e, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x00,
	
	// gamename = bfield1942ps2
	0x67, 0x61, 0x6d, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x00,
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,
	
	// gametype = conquest
	0x67, 0x61, 0x6d, 0x65, 0x74, 0x79, 0x70, 0x65, 0x00,
	0x63, 0x6f, 0x6e, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00,
	
	// gamevariant = Border
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x00,
	0x42, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x00,
	
	// gamever = V1.31a
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x00,
	0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x00,
	
	// gc = 0
	0x67, 0x63, 0x00,
	0x30, 0x00,
	
	// hostname = [CQ]BF2MC-SERVER1 
	0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x00,
	0x5b, 0x43, 0x51, 0x5d, 0x42, 0x46, 0x32, 0x4d, 0x43, 0x2d, 0x53, 0x45, 0x52, 0x56, 0x45, 0x52,
	0x31, 0x00,
	
	// hostport = 3658 
	0x68, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x72, 0x74, 0x00,
	0x33, 0x36, 0x35, 0x38, 0x00,
	
	// localip0 = 78.47.184.23 
	0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x70, 0x30, 0x00,
	0x37, 0x38, 0x2e, 0x34, 0x37, 0x2e, 0x31, 0x38, 0x34, 0x2e, 0x32, 0x33, 0x00,
	
	// localport = 3658 
	0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x70, 0x6f, 0x72, 0x74, 0x00,
	0x33, 0x36, 0x35, 0x38, 0x00,
	
	// map = backstab 
	0x6d, 0x61, 0x70, 0x00,
	0x62, 0x61, 0x63, 0x6b, 0x73, 0x74, 0x61, 0x62, 0x00,
	
	// mapname = 0 
	0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d, 0x65, 0x00,
	0x30, 0x00,
	
	// maxplayers = 24 
	0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00,
	0x32, 0x34, 0x00,
	
	// mc = 1 
	0x6d, 0x63, 0x00,
	0x31, 0x00,
	
	// natneg = 1 
	0x6e, 0x61, 0x74, 0x6e, 0x65, 0x67, 0x00,
	0x31, 0x00,
	
	// ni = -2147483648 
	0x6e, 0x69, 0x00,
	0x2d, 0x32, 0x31, 0x34, 0x37, 0x34, 0x38, 0x33, 0x36, 0x34, 0x38, 0x00,
	
	// nr = 1 
	0x6e, 0x72, 0x00,
	0x31, 0x00,
	
	// numplayers = 9 
	0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00,
	0x39, 0x00,
	
	// numteams = 2 
	0x6e, 0x75, 0x6d, 0x74, 0x65, 0x61, 0x6d, 0x73, 0x00,
	0x32, 0x00,
	
	// password = 0 
	0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x00,
	0x30, 0x00,
	
	// qm = 0 
	0x71, 0x6d, 0x00,
	0x30, 0x00,
	
	// rc = 0 
	0x72, 0x63, 0x00,
	0x30, 0x00,
	
	// region = 65536 
	0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x00,
	0x36, 0x35, 0x35, 0x33, 0x36, 0x00,
	
	// rv = retail 
	0x72, 0x76, 0x00,
	0x72, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x00,
	
	// sr = 1
	0x73, 0x72, 0x00,
	0x31, 0x00,
	
	// statechanged = 1 
	0x73, 0x74, 0x61, 0x74, 0x65, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x00,
	0x31, 0x00,
	
	// teamfraglimit = 0 
	0x74, 0x65, 0x61, 0x6d, 0x66, 0x72, 0x61, 0x67, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x00,
	0x30, 0x00,
	
	// teamplay = 0 
	0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x00,
	0x30, 0x00,
	
	// timeelapsed = 148 
	0x74, 0x69, 0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x00,
	0x31, 0x34, 0x38, 0x00,
	
	// timelimit = 1200 
	0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x00,
	0x31, 0x32, 0x30, 0x30, 0x00,
	
	// xi = 2147483647 
	0x78, 0x69, 0x00,
	0x32, 0x31, 0x34, 0x37, 0x34, 0x38, 0x33, 0x36, 0x34, 0x37, 0x00,
	
	// xr = 20 
	0x78, 0x72, 0x00,
	0x32, 0x30, 0x00,
	
	// deaths_0 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x30, 0x00,
	0x30, 0x00,
	
	// pid_0 = 10046631 
	0x70, 0x69, 0x64, 0x5f, 0x30, 0x00,
	0x31, 0x30, 0x30, 0x34, 0x36, 0x36, 0x33, 0x31, 0x00,
	
	// ping_0 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x30, 0x00,
	0x30, 0x00,
	
	// player_0 = ASSASINO_BR 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x30, 0x00,
	0x41, 0x53, 0x53, 0x41, 0x53, 0x49, 0x4e, 0x4f, 0x5f, 0x42, 0x52, 0x00,
	
	// score_0 = 4 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x30, 0x00,
	0x34, 0x00,
	
	// skill_0 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x30, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_0 = 1 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x30, 0x00,
	0x31, 0x00,
	
	// deaths_1 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x31, 0x00,
	0x30, 0x00,
	
	// pid_1 = 10044023 
	0x70, 0x69, 0x64, 0x5f, 0x31, 0x00,
	0x31, 0x30, 0x30, 0x34, 0x34, 0x30, 0x32, 0x33, 0x00,
	
	// ping_1 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x31, 0x00,
	0x30, 0x00,
	
	// player_1 = _-^FaNtASmA^-_ 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x31, 0x00,
	0x5f, 0x2d, 0x5e, 0x46, 0x61, 0x4e, 0x74, 0x41, 0x53, 0x6d, 0x41, 0x5e, 0x2d, 0x5f, 0x00,
	
	// score_1 = 1 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x31, 0x00,
	0x31, 0x00,
	
	// skill_1 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x31, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_1 = 0 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x31, 0x00,
	0x30, 0x00,
	
	// deaths_2 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x32, 0x00,
	0x30, 0x00,
	
	// pid_2 = 10037796 
	0x70, 0x69, 0x64, 0x5f, 0x32, 0x00,
	0x31, 0x30, 0x30, 0x33, 0x37, 0x37, 0x39, 0x36, 0x00,
	
	// ping_2 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x32, 0x00,
	0x30, 0x00,
	
	// player_2 = revai 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x32, 0x00,
	0x72, 0x65, 0x76, 0x61, 0x69, 0x00,
	
	// score_2 = 0 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x32, 0x00,
	0x30, 0x00,
	// skill_2 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x32, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_2 = 0 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x32, 0x00,
	0x30, 0x00,
	
	// deaths_3 = 1 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x33, 0x00,
	0x31, 0x00,
	
	// pid_3 = 10048679 
	0x70, 0x69, 0x64, 0x5f, 0x33, 0x00,
	0x31, 0x30, 0x30, 0x34, 0x38, 0x36, 0x37, 0x39, 0x00,
	
	// ping_3 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x33, 0x00,
	0x30, 0x00,
	
	// player_3 = kalion 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x33, 0x00,
	0x6b, 0x61, 0x6c, 0x69, 0x6f, 0x6e, 0x00,
	
	// score_3 = 1 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x33, 0x00,
	0x31, 0x00,
	
	// skill_3 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x33, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_3 = 1 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x33, 0x00,
	0x31, 0x00,
	
	// deaths_4 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x34, 0x00,
	0x30, 0x00,
	
	// pid_4 = 10044547 
	0x70, 0x69, 0x64, 0x5f, 0x34, 0x00,
	0x31, 0x30, 0x30, 0x34, 0x34, 0x35, 0x34, 0x37, 0x00,
	
	// ping_4 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x34, 0x00,
	0x30, 0x00,
	
	// player_4 = SWEEPTHELEG 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x34, 0x00,
	0x53, 0x57, 0x45, 0x45, 0x50, 0x54, 0x48, 0x45, 0x4c, 0x45, 0x47, 0x00,
	
	// score_4 = 0 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x34, 0x00,
	0x30, 0x00,
	
	// skill_4 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x34, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_4 = 0 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x34, 0x00,
	0x30, 0x00,
	
	// deaths_5 = 2 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x35, 0x00,
	0x32, 0x00,
	
	// pid_5 = 10042249 
	0x70, 0x69, 0x64, 0x5f, 0x35, 0x00,
	0x31, 0x30, 0x30, 0x34, 0x32, 0x32, 0x34, 0x39, 0x00,
	
	// ping_5 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x35, 0x00,
	0x30, 0x00,
	
	// player_5 = ]7rAgoN]-[aWk 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x35, 0x00,
	0x5d, 0x37, 0x72, 0x41, 0x67, 0x6f, 0x4e, 0x5d, 0x2d, 0x5b, 0x61, 0x57, 0x6b, 0x00,
	
	// score_5 = 6 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x35, 0x00,
	0x36, 0x00,
	
	// skill_5 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x35, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_5 = 0 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x35, 0x00,
	0x30, 0x00,
	
	// deaths_6 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x36, 0x00,
	0x30, 0x00,
	
	// pid_6 = 10037784 
	0x70, 0x69, 0x64, 0x5f, 0x36, 0x00,
	0x31, 0x30, 0x30, 0x33, 0x37, 0x37, 0x38, 0x34, 0x00,
	
	// ping_6 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x36, 0x00,
	0x30, 0x00,
	
	// player_6 = TabsAnDabs 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x36, 0x00,
	0x54, 0x61, 0x62, 0x73, 0x41, 0x6e, 0x44, 0x61, 0x62, 0x73, 0x00,
	
	// score_6 = 3 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x36, 0x00,
	0x33, 0x00,
	
	// skill_6 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x36, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_6 = 1 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x36, 0x00,
	0x31, 0x00,
	
	// deaths_7 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x37, 0x00,
	0x30, 0x00,
	
	// pid_7 = 10036819 
	0x70, 0x69, 0x64, 0x5f, 0x37, 0x00,
	0x31, 0x30, 0x30, 0x33, 0x36, 0x38, 0x31, 0x39, 0x00,
	
	// ping_7 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x37, 0x00,
	0x30, 0x00,
	
	// player_7 = IamLupo 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x37, 0x00,
	0x49, 0x61, 0x6d, 0x4c, 0x75, 0x70, 0x6f, 0x00,
	
	// score_7 = 0 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x37, 0x00,
	0x30, 0x00,
	
	// skill_7 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x37, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_7 = 0 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x37, 0x00,
	0x30, 0x00,
	
	// deaths_8 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x38, 0x00,
	0x30, 0x00,
	
	// pid_8 = 10048589 
	0x70, 0x69, 0x64, 0x5f, 0x38, 0x00,
	0x31, 0x30, 0x30, 0x34, 0x38, 0x35, 0x38, 0x39, 0x00,
	
	// ping_8 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x38, 0x00,
	0x30, 0x00,
	
	// player_8 = Jeod 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x38, 0x00,
	0x4a, 0x65, 0x6f, 0x64, 0x00,
	
	// score_8 = 0 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x38, 0x00,
	0x30, 0x00,
	
	// skill_8 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x38, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_8 = 0 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x38, 0x00,
	0x30, 0x00,
	
	// deaths_9 = 0 
	0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x39, 0x00,
	0x30, 0x00,
	
	// pid_9 = 10037784 
	0x70, 0x69, 0x64, 0x5f, 0x39, 0x00,
	0x31, 0x30, 0x30, 0x33, 0x37, 0x37, 0x38, 0x34, 0x00,
	
	// ping_9 = 0 
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x39, 0x00,
	0x30, 0x00,
	
	// player_9 = TabsAnDabs 
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x39, 0x00,
	0x54, 0x61, 0x62, 0x73, 0x41, 0x6e, 0x44, 0x61, 0x62, 0x73, 0x00,
	
	// score_9 = 0 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x39, 0x00,
	0x30, 0x00,
	
	// skill_9 = rookie 
	0x73, 0x6b, 0x69, 0x6c, 0x6c, 0x5f, 0x39, 0x00,
	0x72, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00,
	
	// team_9 = 0 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x39, 0x00,
	0x30, 0x00,
	
	// score_t0 = 447 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x74, 0x30, 0x00,
	0x34, 0x34, 0x37, 0x00,
	
	// team_t0 = AC 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x30, 0x00,
	0x41, 0x43, 0x00,
	
	// score_t1 = 426 
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x74, 0x31, 0x00,
	0x34, 0x32, 0x36, 0x00,
	
	// team_t1 = US 
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x31, 0x00,
	0x55, 0x53, 0x00,
	
	0x00, 
};

void Browsing::Client::Test()
{	
	int response_offset = 0;
	std::stringstream ss;
	
	//std::vector<unsigned char> request = example_A_request;
	//std::vector<unsigned char> response = example_A_response;
	// std::vector<unsigned char> request = example_B_request;
	// std::vector<unsigned char> response = example_B_response;
	//std::vector<unsigned char> request = example_C_request;
	//std::vector<unsigned char> response = example_C_response;
	//std::vector<unsigned char> request = example_D_request;
	//std::vector<unsigned char> response = example_D_response;
	std::vector<unsigned char> request = example_E_request;
	std::vector<unsigned char> response = example_E_response;
	
	uint32_t cryptlen = CHALLENGE_CRYPT_LEN;
	uint8_t cryptchal[CHALLENGE_CRYPT_LEN];
	uint32_t servchallen = CHALLENGE_SERVER_LEN;
	uint8_t servchal[CHALLENGE_SERVER_LEN];
	uint8_t m_challenge[CHALLENGE_CLIENT_LEN];
	
	// First conclusion:
	// buffer.WriteByte((uint8_t)(cryptlen ^ 0xEC));
	// buffer.WriteBuffer((uint8_t *)&cryptchal, cryptlen);
	ss << std::hex << (cryptlen ^ 0xEC); // Returns e6
	Logger::debug(ss.str());
	response_offset++;
	
	// copy crypt challenge
	ss.str("");
	for(int i = 0; i < CHALLENGE_CRYPT_LEN; i++)
	{
		cryptchal[i] = response[response_offset + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(cryptchal[i]);
	}
	response_offset += CHALLENGE_CRYPT_LEN;
	Logger::debug("cryptchal = " + ss.str());
	
	// Second conclusion
	// buffer.WriteByte((uint8_t)(servchallen ^ 0xEA));
	// buffer.WriteBuffer((uint8_t *)&servchal, servchallen);
	ss.str("");
	ss << std::hex << (servchallen ^ 0xEA) << std::endl; // Returns f3
	Logger::debug(ss.str());
	response_offset++;
	
	// copy crypt challenge
	ss.str("");
	for(int i = 0; i < CHALLENGE_SERVER_LEN; i++)
	{
		servchal[i] = response[response_offset + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(servchal[i]);
	}
	response_offset += CHALLENGE_SERVER_LEN;
	Logger::debug("servchal = " + ss.str());
	
	// Third: Find secret key
	// Found online:
	// https://github.com/devzspy/GameSpy-Openspy-Core/blob/master/Gamemaster.sql
	// size_t seckeylen = m_game.secretkey.length();
    // const char *seckey = m_game.secretkey.c_str();
	size_t seckeylen = 6;
	const char *seckey = "HpWx9z";
	
	// Get the challenge from the clients request
	ss.str("");
	for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
	{
		m_challenge[i] = request[37 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(m_challenge[i]);
	}
	Logger::debug("m_challenge = " + ss.str());
	
	// Update challenge
	for (uint32_t i = 0 ; i < servchallen ; i++)
	{
		m_challenge[(i *  seckey[i % seckeylen]) % CHALLENGE_CLIENT_LEN] ^= (char)((m_challenge[i % CHALLENGE_CLIENT_LEN] ^ servchal[i]) & 0xFF);
	}
	
	GOACryptState m_crypt_state;
	int header_size = 1 + CHALLENGE_CRYPT_LEN + 1 + CHALLENGE_SERVER_LEN;
	
	ss.str("");
	for(int i = header_size; i < response.size(); i++)
	{
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(response[i]);
	}
	Logger::debug("encrypted data = " + ss.str());
	
	// Initialization GOA crypt
	GOACryptInit(&(m_crypt_state), (unsigned char *)(&m_challenge), CHALLENGE_CLIENT_LEN);	
	
	// Decrypt data
	GOADecrypt(&(m_crypt_state), (&response[header_size]), response.size() - header_size);
	
	ss.str("");
	for(int i = header_size; i < response.size(); i++)
	{
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(response[i]);
	}
	Logger::debug("decrypted data = " + ss.str());
	
	/*
	// Encrypt the data again to confirm its the right encrypted data
	GOACryptState m_crypt_state2;
	GOACryptInit(&(m_crypt_state2), (unsigned char *)(&m_challenge), CHALLENGE_CLIENT_LEN);	
	GOAEncrypt(&(m_crypt_state2), (&response[header_size]), response.size() - header_size);
	
	ss.str("");
	for(int i = header_size; i < response.size(); i++)
	{
		ss << std::hex << (int)(response[i]);
	}
	Logger::debug("encrypt data = " + ss.str());
	*/
}

void Browsing::Client::Crack()
{
	std::stringstream ss;
	
	uint8_t crypt_challenge[CHALLENGE_CRYPT_LEN];
	uint8_t server_challenge[CHALLENGE_SERVER_LEN];
	uint8_t client_challenge[CHALLENGE_CLIENT_LEN];
	uint8_t key_challenge[CHALLENGE_CLIENT_LEN];
	
	std::vector<unsigned char> request = example_C_request;
	std::vector<unsigned char> response = example_C_response;
	std::vector<unsigned char> decrypted_data = example_C_decrypt_data;
	
	// copy crypt challenge
	ss.str("");
	for(int i = 0; i < CHALLENGE_CRYPT_LEN; i++)
	{
		crypt_challenge[i] = response[1 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(crypt_challenge[i]);
	}
	Logger::debug("crypt_challenge = " + ss.str());
	
	ss.str("");
	for(int i = 0; i < CHALLENGE_SERVER_LEN; i++)
	{
		server_challenge[i] = response[12 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(server_challenge[i]);
	}
	Logger::debug("server_challenge = " + ss.str());
	
	// Get the challenge from the clients request
	ss.str("");
	for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
	{
		client_challenge[i] = request[37 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(client_challenge[i]);
	}
	Logger::debug("client_challenge = " + ss.str());
	
	/*
		Crack
	*/
	std::string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	std::vector<unsigned char> encryted_data(16, 0x0);
	
	while(true)
	{
		std::string secret_key = "123456";
		
		// Generate random secret key
		for(int i = 0; i < 6; i++)
		{
			secret_key[i] = alphabet[rand() % alphabet.size()];
		}
		
		// Copy backup challenge
		for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
		{
			key_challenge[i] = client_challenge[i];
		}
		
		// Update challenge
		for (uint32_t i = 0 ; i < CHALLENGE_SERVER_LEN; i++)
		{
			key_challenge[(i *  secret_key[i % 6]) % CHALLENGE_CLIENT_LEN] ^= (char)((key_challenge[i % CHALLENGE_CLIENT_LEN] ^ server_challenge[i]) & 0xFF);
		}
		
		// Copy encrypted data
		for(int i = 0; i < 8; i++)
		{
			encryted_data[i] = response[CHALLENGE_CRYPT_LEN + CHALLENGE_SERVER_LEN + 2 + i];
		}
		
		GOACryptState m_crypt_state2;
		GOACryptInit(&(m_crypt_state2), (unsigned char *)(&key_challenge), CHALLENGE_CLIENT_LEN);	
		GOADecrypt(&(m_crypt_state2), &encryted_data[0], 8);
		
		bool correct = true;
		for(int i = 0; i < 8 && correct; i++)
			if(encryted_data[i] != decrypted_data[i])
				correct = false;
		
		if(correct)
		{
			Logger::debug("Found!! secret_key = " + secret_key);
			
			return;
		}
    }
}

