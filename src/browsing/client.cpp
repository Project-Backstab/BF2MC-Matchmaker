#include <unistd.h>
#include <iostream>
#include <iomanip>

#include <settings.h>
#include <logger.h>
#include <server.h>
#include <globals.h>
#include <util.h>
#include <database.h>
#include <browsing/sb_crypt.h>
#include <browsing/constants.h>

#include <browsing/client.h>

typedef void (Browsing::Client::*RequestActionFunc)(const std::vector<unsigned char>&);

static std::map<uint8_t, RequestActionFunc> mRequestActions = 
{
	{ REQUEST_SERVER_LIST,    &Browsing::Client::requestServerList   },
	//{ REQUEST_SERVER_INFO,    &Browsing::Client::requestServerInfo   },
	//{ REQUEST_SEND_MESSAGE,   &Browsing::Client::requestSendMessage  },
	//{ REQUEST_KEEPALIVE,      &Browsing::Client::requestKeepAlive    },
	//{ REQUEST_MAPLOOP,        &Browsing::Client::requestMapLoop      },
	//{ REQUEST_PLAYERSEARCH,   &Browsing::Client::requestPlayerSearch },
};

Browsing::Client::Client(int socket, struct sockaddr_in address)
{
	this->_socket = socket;
	this->_address = address;
}

Browsing::Client::~Client()
{
	this->Disconnect();
}

void Browsing::Client::Listen()
{
	while(true)
	{
		std::vector<unsigned char> buffer(4096, 0);
		
		int v = read(this->_socket, &(buffer[0]), 4096);
		
		// If error or no data is recieved we end the connection
		if(v <= 0)
		{
			break;
		}
		
		// Resize buffer
		buffer.resize(v);
		
		this->_LogTransaction("-->", Util::Buffer2String(buffer));
		
		this->onRequest(buffer);
	}
	
	this->Disconnect();
}

void Browsing::Client::Disconnect()
{
	this->Close();
	g_browsing_server->onClientDisconnect(*this);
}

/*
	Events
*/
void Browsing::Client::onRequest(const std::vector<unsigned char>& request)
{
	int size = static_cast<uint16_t>(request[0]);
	uint8_t action = static_cast<uint8_t>(request[2]);
	
	// Find function
	auto it = mRequestActions.find(action);
	if (it != mRequestActions.end())
	{
		// Get Function address
		RequestActionFunc func = it->second;
	
		// Execute action function with class object.
		(this->*(func))(request);
	}
	else
	{
		Logger::warning("action \"" + std::to_string(action) + "\"not implemented!", Server::Type::Browsing);
		
		this->Disconnect();
	}
}

/*

	filter:
		gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=20 and xr>=20)and (region & 1)=0
		
		Min/Max Players:
			Max:				numplayers<=22
			Min:				numplayers>=1
		Game Mode:
			Conquest:			gc=0 and gametype='conquest'
			CTF:				gc=0 and gametype='capturetheflag'
		Maps: 
			Backstab:			mapname=0 and mc=1
			DeadlyPass:			mapname=1 and mc=1
			BridgeToFar:		mapname=2 and mc=1
			Dammage:			mapname=3 and mc=1
			HarborEdge:			mapname=4 and mc=1
			Honor:				mapname=5 and mc=1
			LittleBigEye:		mapname=6 and mc=1
			MissleCrisis		mapname=7 and mc=1
			ColdFront			mapname=8 and mc=1
			RussianBorder:		mapname=9 and mc=1
			SpecialOp:			mapname=10 and mc=1
			TheBlackGold		mapname=11 and mc=1
			TheNest				mapname=12 and mc=1
			[All Maps Playlist]	mc=2
			[Assualt Maps]		mc=3
			[Incursion Maps]	mc=4
			[Domination Maps]	mc=5
		Ranked:
			On:					(nr>1 or xr<20)
			Off:				nr=1 and xr=20
		Stats Tracking:
			On:					sr=1
			Off:				sr=0
		
		Clan fight:
			gamever='V1.31a' and (teamplay!=0 and (c0=-1 or c1=-1 or c0=19 or c1=19) and maxplayers<=24 and numplayers!=maxplayers and nr<=20 and xr>=20)and (region & 1)=0
			
			gamever='V1.31a' and (teamplay!=0 and (c0=-1 or c1=-1 or c0=21 or c1=21) and maxplayers<=24 and numplayers!=maxplayers and nr<=1 and xr>=1 and sr=1)and (region & 1)=0
			
			
*/
void Browsing::Client::requestServerList(const std::vector<unsigned char>& request)
{	
	if(request.size() < 50)
	{
		return;
	}
	
	const char* start = reinterpret_cast<const char*>(&request[0]) + 45;
	std::string filter(start);
	std::string key_list(start + filter.size() + 1);
	std::vector<unsigned char> response(CHALLENGE_HEADER_LEN + 8, 0x0);
	Battlefield::GameServers game_servers;
	
	//Logger::debug("filter = " + filter);
	//Logger::debug("key_list = " + key_list);
	
	// Only execute once
	if(filter.find("(region & 1)!=0") != std::string::npos)
	{
		g_database->queryGameServers(game_servers);
	}
	
	if(filter.find("hostname") != std::string::npos)
	{
		Battlefield::GameServer game_server;

		//game_server.SetIp("86.87.139.235");
		game_server.SetIp("86.160.99.212");
		game_server.SetPort(3658);
		game_server.SetFlag(59);
		
		game_servers.push_back(game_server);
	}
	
	for(Battlefield::GameServer game_server : game_servers)
	{
		//Battlefield::GameServer game_server;
		//game_server.useExample();
	
		uint16_t port = game_server.GetPort();
		uint8_t flag = game_server.GetFlag();
		
		// Server flag
		response.push_back(game_server.GetFlag());
		
		// wan ip
		response.insert(response.end(), game_server.GetIp(), game_server.GetIp() + 4);
		
		if(flag & FLAG_NONSTANDARD_PORT)         // -> wan port
		{
			response.push_back(port / 256);
			response.push_back(port % 256);
		}
		
		if(flag & FLAG_PRIVATE_IP)               // -> localip0 ip
		{              
			response.insert(response.end(), game_server.GetIp(), game_server.GetIp() + 4);
		}
		
		if(flag & FLAG_NONSTANDARD_PRIVATE_PORT) // -> localport
		{
			response.push_back(port / 256);
			response.push_back(port % 256);
		}
		
		if(flag & FLAG_ICMP_IP)                  // -> icmp ip
		{
			response.insert(response.end(), game_server.GetIp(), game_server.GetIp() + 4);
		}
	}
	
	// End data
	response.push_back(0x00); // Empty flag means end of servers
	
	this->_Encrypt(request, response);
	
	this->Send(response);
		
	//this->_LogTransaction("<--", str_request);
}

/*
	Private functions
*/
void Browsing::Client::_LogTransaction(const std::string& direction, const std::string& response) const
{
	std::shared_lock<std::shared_mutex> guard2(g_mutex_settings); // settings lock  (read)
	
	bool show_console = (g_settings["browsing"]["show_requests"].asBool() && direction == "-->") ||
						(g_settings["browsing"]["show_responses"].asBool() && direction == "<--");
	
	Logger::info(this->GetAddress() + " " + direction + " " + response,
			Server::Type::Browsing, show_console);
}

void Browsing::Client::_Encrypt(const std::vector<unsigned char>& request, std::vector<unsigned char>& response)
{
	uint8_t crypt_challenge[CHALLENGE_CRYPT_LEN];
	uint8_t server_challenge[CHALLENGE_SERVER_LEN];
	uint8_t client_challenge[CHALLENGE_CLIENT_LEN];
	
	GOACryptState m_crypt_state;
	
	// Push Crypt Challenge
	response[0] = 0xe6; // CHALLENGE_CRYPT_LEN ^ 0xec = 0xe6
	for(int i = 0; i < CHALLENGE_CRYPT_LEN; i++)
	{
		crypt_challenge[i] = 0x0;
		response[1 + i] = crypt_challenge[i];
	}

	// Push Server challenge
	response[CHALLENGE_CRYPT_LEN + 1] = 0xf3; // CHALLENGE_SERVER_LEN ^ 0xea = 0xf3
	for(int i = 0; i < CHALLENGE_SERVER_LEN; i++)
	{
		server_challenge[i] = 0x0;
		response[CHALLENGE_CRYPT_LEN + 2 + i] = server_challenge[i];
	}
	
	// Get client challenge
	for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
	{
		client_challenge[i] = request[37 + i];
	}
	
	// Generate challenge encryption/decryption key
	for (uint32_t i = 0 ; i < CHALLENGE_SERVER_LEN; i++)
	{
		uint8_t index = (i *  SECRET_KEY[i % SECRET_KEY_LEN]) % CHALLENGE_CLIENT_LEN;
		uint8_t value = (client_challenge[i % CHALLENGE_CLIENT_LEN] ^ server_challenge[i]) & 0xFF;
		
		client_challenge[index] ^= value;
	}
	
	// Add to data to say confirm decryption went correctly
	response.push_back(0xFF);
	response.push_back(0xFF);
	response.push_back(0xFF);
	response.push_back(0xFF);
	
	// Encrypt data
	GOACryptInit(&(m_crypt_state), (unsigned char *)(&client_challenge), CHALLENGE_CLIENT_LEN);
	GOAEncrypt(&(m_crypt_state), &response[CHALLENGE_HEADER_LEN], response.size() - CHALLENGE_HEADER_LEN);
}

/*
	Example and test
*/
std::vector<unsigned char> example_A_request = {
	0x01, 0x5e,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x25, 0x60, 0x50, 0x27, 0x6c, 0x6d, 0x64, 0x55,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)!=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x21, 0x3d, 0x30, 0x00,
	
	// key_list: \hostname\gametype\gamever\hostport\timelimit\timeelapsed\mapname\numplayers\maxplayers\
	             teamplay\team_t\ping_\c0\c1\n0\n1\c0c\c1c\nr\xr\ff\mc\gc\rc\sr\ni\xi\qm
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x14, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_A_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0xbb, 0x79, 0x76, 0xb5, 0xb9, 0xe1, 0xa6, 0xaf, 0x08, 0x15,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length // data
	0xc7, 0x63, 0x80, 0x6e, 0xd7, 0x70, 0x7a, 0x11, 0xc4, 0x03, 0x1b, 0xa0, 0x70, 0x13, 0x7e, 0x69, // data 1-16
	0x69, 0x53, 0x33, 0x45, 0x92, 0xee, 0x3e, 0x09, 0xa4,
	
	// Encrypted data
	0xe6, 0x35, 0x83, 0xc4, 0x70, 0x40, 0xdf, 0x4f, 0x14, 0x77, 0x52, 0xb3, 0x4c, 0xf8, 0xca, 0xec,
	0x9f, 0xd7, 0x74, 0xe9, 0x03, 0x49, 0xe8, 0xcb, 0xef, 0xd8, 0xb3, 0x01, 0xfc, 0xe6, 0xe1, 0xd0,
	0x03, 0xbe, 0x61, 0x43, 0x2a, 0x66, 0xfb, 0x13, 0x3d, 0x67, 0xc5, 0x17, 0xd9, 0x53, 0x52, 0xbf,
	0xa8, 0x87, 0xe6, 0x20, 0x2d, 0xd1, 0xe9, 0xb8, 0x82, 0x29, 0xac, 0xb1, 0x93, 0x63, 0x10, 0xf2,
	0xa3, 0x7f, 0x60, 0x61, 0x31, 0xc3, 0x22, 0xa0, 0x7b, 0x88, 0x25, 0xf1, 0xbe, 0xee, 0x5b, 0x44,
	0x43, 0xab, 0xb9, 0x84, 0x58, 0xb4, 0xf4, 0xf3, 0xf6, 0x61, 0x81, 0x31, 0x04, 0x9c, 0xf5, 0xff,
	0xe2, 0x79, 0x65, 0x98, 0x6d, 0x1d, 0x4d, 0x00, 0xa8, 0x2d, 0x1d, 0x4f, 0xfd, 0x68, 0x7e, 0x7e,
	0xb3, 0x0f, 0xda, 0x4c, 0x90, 0xe9, 0x89, 0x64, 0x3d, 0xbe, 0xdf, 0xd3, 0x31, 0x2f, 0x1a, 0x96,
	0x89, 0xef, 0x00, 0x89, 0x7a, 0xe8, 0x56, 0xa1, 0x5a, 0x95, 0x66, 0xd4, 0x20, 0x0b, 0x20, 0xbc,
	0xe7, 0xe6, 0xea, 0x55, 0xdd, 0xd3, 0x33, 0x9c, 0x37, 0x82, 0xcb, 0xc1, 0x8d, 0x40, 0xf3, 0x0f,
	0x33, 0x13, 0x1f, 0xd4, 0x40, 0x65, 0xd1, 0x3f, 0xd1, 0xbb, 0xf6, 0x71, 0x88, 0xfc, 0x9c, 0xa4,
	0x8b, 0xbe, 0x41, 0xf6, 0x11, 0x0b, 0x09, 0x7f, 0x1d, 0x72, 0x04, 0x05, 0x4b, 0xaf, 0xe8, 0x0b,
	0x62, 0x7b, 0xce, 0xcf, 0x27, 0xd0, 0xb6, 0x19, 0x4a, 0x25, 0x94, 0x8f, 0x6a, 0x50, 0xa4, 0xec,
	0x30, 0x19, 0xda, 0x08, 0xc7, 0xa1, 0x90, 0x2e, 0x83, 0x44, 0x16, 0x49, 0x6b, 0x69, 0x6c, 0x63,
	0x17, 0x59, 0x28, 0xc9, 0xa9, 0x6f, 0xcb, 0xce, 0x22, 0x9f
};

std::vector<unsigned char> example_B_request = {
	0x01, 0x5d,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x3b, 0x6e, 0x32, 0x56, 0x72, 0x4d, 0x2a, 0x30,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x3d, 0x30, 0x00,
	
	// key_list: \hostname\gametype\gamever\hostport\timelimit\timeelapsed\mapname\numplayers\maxplayers\
	             teamplay\team_t\ping_\c0\c1\n0\n1\c0c\c1c\nr\xr\ff\mc\gc\rc\sr\ni\xi\qm
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x12, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_B_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0xe2, 0x7f, 0x2f, 0x6e, 0x42, 0x18, 0x35, 0x59, 0x19, 0x1b,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length
	0x7b, 0x7a, 0xbd, 0x2d, 0x2e, 0xb3, 0xa5, 0x7e, 0x9f, 0x91, 0x77, 0x74, 0xc0, 0xcd, 0x08, 0xf5, // data 1-16
	0x86, 0x60, 0xc0, 0xf5, 0x4c, 0xa2, 0x74, 0x7b, 0x10,                                           // data 17-25
	
	// Encrypted data
	0x46, 0xb5, 0xa5, 0x93, 0xf3, 0xaa, 0x48, 0xc4, 0x5e, 0xdb, 0x1a, 0x64, 0xf4, 0xee, 0x6f, 0x43,
	0xa7, 0x44, 0x73, 0x4b, 0x98, 0xa7, 0xe6, 0x96, 0xfb, 0x2f, 0xe4, 0xe2, 0xbd, 0xe6, 0x71, 0xae,
	0x7b, 0x76, 0xee, 0x99, 0x36, 0xef, 0x3b, 0x62, 0xfd, 0xd6, 0xbb, 0x55, 0x88, 0xb4, 0x43, 0xe1,
	0xd1, 0x85, 0x30, 0x2d, 0x45, 0xef, 0x08, 0x8f, 0x79, 0x6a, 0x78, 0xaf, 0x37, 0xe4, 0x79, 0x8d,
	0xa8, 0x1d, 0x1b, 0xa5, 0x5e, 0x9a, 0x03, 0xa2, 0x9a, 0xb3, 0xa2, 0x0d, 0xf8, 0xc9, 0xe3, 0xf1,
	0xce, 0xb3, 0x1d, 0x93, 0x6d, 0xc9, 0xf3, 0x25, 0x99, 0xb8, 0x77, 0xfb, 0xd4, 0x6b, 0x7b, 0x2c,
	0x3c, 0xa3, 0xe0, 0x19, 0x8b, 0x6f, 0x2a, 0x79, 0xa7, 0x54, 0xc0, 0x9f, 0xa9, 0x7e, 0xea, 0x90,
	0xe1, 0xd1, 0x22, 0x5c, 0x8f, 0x8a, 0x87, 0x76, 0x5c, 0x21, 0x01, 0x5c, 0x35, 0x0f, 0x20, 0xe4,
	0x8b, 0x7f, 0xfc, 0x0f, 0xec, 0x32, 0x5a, 0x2c, 0xbd, 0x61, 0xdd, 0x11, 0xc6, 0x75, 0x21, 0x62,
	0x89, 0x05, 0x6c, 0x0a, 0xc2, 0xf3, 0xfd, 0xfe, 0x73, 0xea, 0x41, 0x44, 0xb6, 0xb6, 0x1e, 0x2d,
	0x15, 0x24, 0xf4, 0x64, 0x9c, 0x41, 0x06, 0x3f, 0xa8, 0xf8, 0x49, 0x3f, 0x63, 0x2f, 0xe0, 0x74,
	0x31, 0xe8, 0x43, 0xa0, 0x23, 0x3d, 0xae, 0x4d, 0x5e, 0x95, 0xcf, 0xcd, 0x83, 0x3d, 0x25, 0xbd,
	0x22, 0xaf, 0x72, 0x39, 0xc3, 0xea, 0x94, 0x72
};

std::vector<unsigned char> example_C_request = {
	0x01, 0x5e,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x34, 0x68, 0x6b, 0x54, 0x61, 0x5c, 0x2d, 0x6d,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)!=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x21, 0x3d, 0x30, 0x00,
	
	// key_list: \hostname\gametype\gamever\hostport\timelimit\timeelapsed\mapname\numplayers\maxplayers\
	             teamplay\team_t\ping_\c0\c1\n0\n1\c0c\c1c\nr\xr\ff\mc\gc\rc\sr\ni\xi\qm
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x14, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_C_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0x48, 0x3c, 0xdb, 0xb6, 0x0b, 0x68, 0x4f, 0x45, 0xb1, 0xcd,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length
	0x8e, 0x71, 0x43, 0xfa, 0xdb, 0x0c, 0x42, 0xef, 0xaf, 0x68, 0xfb, 0x64, 0x4b, 0x53, 0xac, 0x69, // data 1-16
	0xbf, 0x74, 0xe8, 0x4d, 0x6f, 0x30, 0x8a, 0x4a, 0xe6,                                           // data 17-25
	
	// Encrypted data
	0x92, 0xbd, 0x4c, 0xaf, 0x27, 0x6d, 0x87, 0x87, 0x3a, 0xfa, 0x44, 0x67, 0x16, 0xbc, 0x8e, 0x2e,
	0xe0, 0x9f, 0xfb, 0x0d, 0xdf, 0x37, 0x5b, 0xe4, 0x8a, 0xc4, 0x06, 0x21, 0x7d, 0x55, 0x73, 0xfe,
	0x5b, 0x22, 0x23, 0xd9, 0x9e, 0xd2, 0xe3, 0xbd, 0xd9, 0xd2, 0xcd, 0x2c, 0x6b, 0xc6, 0x2a, 0xe0,
	0x34, 0x7b, 0xfd, 0x6a, 0xed, 0xad, 0xcf, 0xca, 0x88, 0x5e, 0xa3, 0x9e, 0xef, 0xc4, 0x0f, 0x95,
	0x84, 0xf4, 0xaa, 0xd7, 0x04, 0x03, 0xfd, 0xfd, 0x0e, 0xc9, 0xd3, 0xeb, 0x78, 0x0c, 0x39, 0xc7,
	0xbb, 0xe8, 0xa3, 0x8a, 0x49, 0x31, 0xb1, 0xe1, 0xde, 0x74, 0x40, 0x48, 0x37, 0x45, 0x1a, 0x4f,
	0xb3, 0x3a, 0xc8, 0x2c, 0x5d, 0x22, 0xd3, 0x59, 0xb1, 0x40, 0x54, 0x21, 0xdd, 0x20, 0xa4, 0x89,
	0x26, 0xfc, 0x2c, 0x45, 0x12, 0x7e, 0x0e, 0x67, 0xc9, 0x53, 0xb2, 0x05, 0xa6, 0xbc, 0x74, 0xba,
	0x63, 0x21, 0x82, 0x49, 0x68, 0xd7, 0x26, 0x39, 0xc3, 0xdc, 0x56, 0xee, 0x36, 0x24, 0xd6, 0x93,
	0x83, 0xe6, 0x8a, 0x84, 0x53, 0x00, 0x80, 0xb9, 0x5c, 0x19, 0xf4, 0xa6, 0x54, 0xc3, 0xc0, 0xa4,
	0x1a, 0x0b, 0x03, 0x32, 0xb2, 0x5f, 0x6f, 0x83, 0xef, 0x38, 0xed, 0x5a, 0x39, 0xa2, 0xbe, 0x0d,
	0x8b, 0xa8, 0x14, 0xaf, 0xaa, 0x8f, 0x3a, 0x37, 0xc5, 0xab, 0x0a, 0x01, 0x8a, 0x67, 0xc2, 0x62,
	0xac, 0x53, 0x19, 0xd1, 0x51, 0xa2, 0x81, 0x05, 0xc3, 0x6a, 0xde, 0x17, 0xb3, 0x4a, 0x5d, 0xc2,
	0xb4, 0xe6, 0x91, 0x02, 0x4a, 0x0b, 0x75, 0x70, 0x86, 0xe1, 0xe8, 0x93, 0x3f, 0x7c, 0x5a, 0xc8,
	0x55, 0xd7, 0x04, 0x7a, 0x7a, 0x46, 0x4f, 0x5d, 0x88, 0x13
};

std::vector<unsigned char> example_D_request = {
	0x01, 0x5d,                                                                                    // Total Bytes to read
	0x00,                                                                                          // REQUEST_SERVER_LIST
	0x01,                                                                                          // protocol_version
	0x03,                                                                                          // encoding_version
	0x00, 0x00, 0x00, 0x00,                                                                        // game_version
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // for_gamename
	0x62, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x31, 0x39, 0x34, 0x32, 0x70, 0x73, 0x32, 0x00,            // from_gamename
	0x25, 0x70, 0x24, 0x56, 0x7c, 0x29, 0x3e, 0x5d,                                                // client challenge
	
	// filter: gamever='V1.31a' and (teamplay=0 and numplayers<=23 and numplayers>=0 and numplayers!=maxplayers and nr<=2 and xr>=2)and (region & 1)=0
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x3d, 0x27, 0x56, 0x31, 0x2e, 0x33, 0x31, 0x61, 0x27,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x3d, 0x30,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x3c,
	0x3d, 0x32, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x73, 0x3e, 0x3d, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x73, 0x21, 0x3d, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
	0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x72, 0x3c, 0x3d, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x78,
	0x72, 0x3e, 0x3d, 0x32, 0x29, 0x61, 0x6e, 0x64, 0x20, 0x28, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e,
	0x20, 0x26, 0x20, 0x31, 0x29, 0x3d, 0x30, 0x00,
	
	// key_list
	0x5c, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79,
	0x70, 0x65, 0x5c, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x5c, 0x68, 0x6f, 0x73, 0x74, 0x70,
	0x6f, 0x72, 0x74, 0x5c, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5c, 0x74, 0x69,
	0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x5c, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d,
	0x65, 0x5c, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x6d, 0x61, 0x78,
	0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x5c, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79,
	0x5c, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x5c, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x5c, 0x63, 0x30,
	0x5c, 0x63, 0x31, 0x5c, 0x6e, 0x30, 0x5c, 0x6e, 0x31, 0x5c, 0x63, 0x30, 0x63, 0x5c, 0x63, 0x31,
	0x63, 0x5c, 0x6e, 0x72, 0x5c, 0x78, 0x72, 0x5c, 0x66, 0x66, 0x5c, 0x6d, 0x63, 0x5c, 0x67, 0x63,
	0x5c, 0x72, 0x63, 0x5c, 0x73, 0x72, 0x5c, 0x6e, 0x69, 0x5c, 0x78, 0x69, 0x5c, 0x71, 0x6d, 0x00,
	
	0x00, 0x00, 0x00, 0x80,                                                                         // options
	0x12, 0x00, 0x00, 0x00                                                                          // options max_results
};

std::vector<unsigned char> example_D_response = {
	// Crypt challenge
	0xe6,                                                                                           // length
	0x48, 0x3c, 0xdb, 0xb6, 0x0b, 0x68, 0x4f, 0x45, 0xb1, 0xcd,                                     // data
	
	// Server challenge
	0xf3,                                                                                           // length
	0x8e, 0x71, 0x43, 0xfa, 0xdb, 0x0c, 0x42, 0xef, 0xaf, 0x68, 0xfb, 0x64, 0x4b, 0x53, 0xac, 0x69, // data 1-16
	0xbf, 0x74, 0xe8, 0x4d, 0x6f, 0x30, 0x8a, 0x4a, 0xe6,                                           // data 17-25
	
	// Encrypted data
	0xa6, 0x4e, 0x0e, 0xe7, 0xbc, 0xdf, 0xa6, 0xc1, 0x47, 0x28, 0x28, 0x44, 0xeb, 0x9e, 0xac, 0x94,
	0x71, 0x36, 0xcf, 0xed, 0x49, 0x98, 0x2d, 0xa9, 0x44, 0xbf, 0xe6, 0xc2, 0x6d, 0xa9, 0x15, 0x00,
	0x83, 0xa6, 0x30, 0xe6, 0x63, 0x9a, 0xcb, 0x85, 0x91, 0xad, 0xfe, 0x22, 0x1b, 0xac, 0x27, 0xe4,
	0xee, 0x4a, 0xe6, 0x31, 0x03, 0x18, 0x30, 0x31, 0x2b, 0xb5, 0xca, 0x60, 0xd7, 0xc6, 0x64, 0x25,
	0x0c, 0x20, 0x08, 0x47, 0x95, 0x50, 0x98, 0xb5, 0xd3, 0xa8, 0x6c, 0x4d, 0x1e, 0x27, 0x43, 0xc0,
	0x8e, 0xf3, 0x9d, 0xfd, 0x83, 0xb6, 0x4d, 0x4c, 0x6b, 0x39, 0x72, 0x0d, 0x1a, 0x97, 0x55, 0x4c,
	0x7f, 0xe5, 0xf4, 0x32, 0x82, 0xd4, 0x29, 0xe1, 0x29, 0x4a, 0x4a, 0x68, 0x28, 0x62, 0xe6, 0xbe,
	0xed, 0xfa, 0xd2, 0x63, 0xc1, 0x1d, 0x54, 0xaf, 0xcc, 0x68, 0x11, 0x1e, 0x3e, 0xda, 0xb3, 0x65,
	0x9f, 0x1a, 0x61, 0x99, 0xcd, 0x3d, 0x2f, 0x47, 0xaf, 0xdb, 0x52, 0xb4, 0xa2, 0x62, 0xd5, 0xee,
	0x5b, 0xb1, 0x32, 0xd9, 0xea, 0x82, 0xac, 0x43, 0xab, 0x5c, 0x77, 0xd9, 0xab, 0x4b, 0xf0, 0x07,
	0x58, 0x6f, 0x9d, 0xf3, 0x64, 0xd2, 0x37, 0x8d, 0x2e, 0x72, 0x45, 0x84, 0x89, 0x18, 0x98, 0x9c,
	0x13, 0x7e, 0x1a, 0x89, 0x29, 0x6b, 0x5b, 0x0b, 0x08, 0x0b, 0x7f, 0x11, 0x41, 0x50, 0x1e, 0x55,
	0x6e, 0xa9, 0x13, 0x99, 0x88, 0xcc, 0xf0, 0x76
};

std::vector<unsigned char> example_C_decrypt_data = {
	// Request
	0x56, 0x57, 0x8b, 0xeb,                                                       // Request ip: 86.87.139.235
	0x19, 0x64,                                                                   // Requested: port 6500

	// ?? Header information ??
	0x1c, 0x00,                                                                   // Total header items: 28
	0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                   // hostname
	0x67, 0x61, 0x6d, 0x65, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00,                   // gametype
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x00, 0x00,                         // gamever
	0x68, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x72, 0x74, 0x00, 0x00,                   // hostport
	0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x00, 0x00,             // timelimit
	0x74, 0x69, 0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x00, 0x00, // timeelapsed
	0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                         // mapname
	0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // numplayers
	0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // maxplayers
	0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x00, 0x00,                   // teamplay
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x00, 0x00,                               // team_t
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x00, 0x00,                                     // ping_
	0x63, 0x30, 0x00, 0x00,                                                       // c0
	0x63, 0x31, 0x00, 0x00,                                                       // c1
	0x6e, 0x30, 0x00, 0x00,                                                       // n0
	0x6e, 0x31, 0x00, 0x00,                                                       // n1
	0x63, 0x30, 0x63, 0x00, 0x00,                                                 // c0c
	0x63, 0x31, 0x63, 0x00, 0x00,                                                 // c1c
	0x6e, 0x72, 0x00, 0x00,                                                       // nr
	0x78, 0x72, 0x00, 0x00,                                                       // xr
	0x66, 0x66, 0x00, 0x00,                                                       // ff
	0x6d, 0x63, 0x00, 0x00,                                                       // mc
	0x67, 0x63, 0x00, 0x00,                                                       // gc
	0x72, 0x63, 0x00, 0x00,                                                       // rc
	0x73, 0x72, 0x00, 0x00,                                                       // sr
	0x6e, 0x69, 0x00, 0x00,                                                       // ni
	0x78, 0x69, 0x00, 0x00,                                                       // xi
	0x71, 0x6d, 0x00, 0x00,                                                       // qm

	// New server
	0x3b,                            // flags: UNSOLICITED_UDP_FLAG | PRIVATE_IP_FLAG | ICMP_IP_FLAG | NONSTANDARD_PORT_FLAG | NONSTANDARD_PRIVATE_PORT_FLAG
	0xa8, 0x77, 0xbd, 0x95,          //                                  wan ip:      168.119.189.149
	0x0e, 0x4a,                      // NONSTANDARD_PORT_FLAG         -> wan port:    3658
	0xa8, 0x77, 0xbd, 0x95,          // PRIVATE_IP_FLAG               -> localip0 ip: 168.119.189.149
	0x0e, 0x4a,                      // NONSTANDARD_PRIVATE_PORT_FLAG -> localport:   3658
	0xa8, 0x77, 0xbd, 0x95,          // ICMP_IP_FLAG                  -> icmp ip:     168.119.189.149

	// New server
	0x3b,                            // flags: UNSOLICITED_UDP_FLAG | PRIVATE_IP_FLAG | ICMP_IP_FLAG | NONSTANDARD_PORT_FLAG | NONSTANDARD_PRIVATE_PORT_FLAG
	0x4e, 0x2f, 0xb8, 0x17,          //                                  wan ip:      78.47.184.23
	0x0e, 0x4a,                      // NONSTANDARD_PORT_FLAG         -> wan port:    3658
	0x4e, 0x2f, 0xb8, 0x17,          // PRIVATE_IP_FLAG               -> localip0 ip: 78.47.184.23
	0x0e, 0x4a,                      // NONSTANDARD_PRIVATE_PORT_FLAG -> localport:   3658
	0x4e, 0x2f, 0xb8, 0x17,          // ICMP_IP_FLAG                  -> icmp ip:     78.47.184.23

	// End decrypted data
	0x00, 0xff, 0xff, 0xff, 0xff
};

std::vector<unsigned char> example_D_decrypt_data = {
	// Request
	0x56, 0x57, 0x8b, 0xeb,                                                       // Request ip: 86.87.139.235
	0x19, 0x64,                                                                   // Requested: port 6500
	
	// ?? Header information ??
	0x1c, 0x00,                                                                   // Total header items: 28
	0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                   // hostname
	0x67, 0x61, 0x6d, 0x65, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00,                   // gametype
	0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x00, 0x00,                         // gamever
	0x68, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x72, 0x74, 0x00, 0x00,                   // hostport
	0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x00, 0x00,             // timelimit
	0x74, 0x69, 0x6d, 0x65, 0x65, 0x6c, 0x61, 0x70, 0x73, 0x65, 0x64, 0x00, 0x00, // timeelapsed
	0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x00,                         // mapname
	0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // numplayers
	0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x00, 0x00,       // maxplayers
	0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x00, 0x00,                   // teamplay
	0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x00, 0x00,                               // team_t
	0x70, 0x69, 0x6e, 0x67, 0x5f, 0x00, 0x00,                                     // ping_
	0x63, 0x30, 0x00, 0x00,                                                       // c0
	0x63, 0x31, 0x00, 0x00,                                                       // c1
	0x6e, 0x30, 0x00, 0x00,                                                       // n0
	0x6e, 0x31, 0x00, 0x00,                                                       // n1
	0x63, 0x30, 0x63, 0x00, 0x00,                                                 // c0c
	0x63, 0x31, 0x63, 0x00, 0x00,                                                 // c1c
	0x6e, 0x72, 0x00, 0x00,                                                       // nr
	0x78, 0x72, 0x00, 0x00,                                                       // xr
	0x66, 0x66, 0x00, 0x00,                                                       // ff
	0x6d, 0x63, 0x00, 0x00,                                                       // mc
	0x67, 0x63, 0x00, 0x00,                                                       // gc
	0x72, 0x63, 0x00, 0x00,                                                       // rc
	0x73, 0x72, 0x00, 0x00,                                                       // sr
	0x6e, 0x69, 0x00, 0x00,                                                       // ni
	0x78, 0x69, 0x00, 0x00,                                                       // xi
	0x71, 0x6d, 0x00, 0x00,                                                       // qm
	
	// End decrypted data
	0x00, 0xff, 0xff, 0xff, 0xff
};

void Browsing::Client::Test()
{	
	int response_offset = 0;
	std::stringstream ss;
	
	//std::vector<unsigned char> request = example_A_request;
	//std::vector<unsigned char> response = example_A_response;
	// std::vector<unsigned char> request = example_B_request;
	// std::vector<unsigned char> response = example_B_response;
	std::vector<unsigned char> request = example_C_request;
	std::vector<unsigned char> response = example_C_response;
	//std::vector<unsigned char> request = example_D_request;
	//std::vector<unsigned char> response = example_D_response;
	
	uint32_t cryptlen = CHALLENGE_CRYPT_LEN;
	uint8_t cryptchal[CHALLENGE_CRYPT_LEN];
	uint32_t servchallen = CHALLENGE_SERVER_LEN;
	uint8_t servchal[CHALLENGE_SERVER_LEN];
	uint8_t m_challenge[CHALLENGE_CLIENT_LEN];
	
	// First conclusion:
	// buffer.WriteByte((uint8_t)(cryptlen ^ 0xEC));
	// buffer.WriteBuffer((uint8_t *)&cryptchal, cryptlen);
	ss << std::hex << (cryptlen ^ 0xEC); // Returns e6
	Logger::debug(ss.str());
	response_offset++;
	
	// copy crypt challenge
	ss.str("");
	for(int i = 0; i < CHALLENGE_CRYPT_LEN; i++)
	{
		cryptchal[i] = response[response_offset + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(cryptchal[i]);
	}
	response_offset += CHALLENGE_CRYPT_LEN;
	Logger::debug("cryptchal = " + ss.str());
	
	// Second conclusion
	// buffer.WriteByte((uint8_t)(servchallen ^ 0xEA));
	// buffer.WriteBuffer((uint8_t *)&servchal, servchallen);
	ss.str("");
	ss << std::hex << (servchallen ^ 0xEA) << std::endl; // Returns f3
	Logger::debug(ss.str());
	response_offset++;
	
	// copy crypt challenge
	ss.str("");
	for(int i = 0; i < CHALLENGE_SERVER_LEN; i++)
	{
		servchal[i] = response[response_offset + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(servchal[i]);
	}
	response_offset += CHALLENGE_SERVER_LEN;
	Logger::debug("servchal = " + ss.str());
	
	// Third: Find secret key
	// Found online:
	// https://github.com/devzspy/GameSpy-Openspy-Core/blob/master/Gamemaster.sql
	// size_t seckeylen = m_game.secretkey.length();
    // const char *seckey = m_game.secretkey.c_str();
	size_t seckeylen = 6;
	const char *seckey = "HpWx9z";
	
	// Get the challenge from the clients request
	ss.str("");
	for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
	{
		m_challenge[i] = request[37 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(m_challenge[i]);
	}
	Logger::debug("m_challenge = " + ss.str());
	
	// Update challenge
	for (uint32_t i = 0 ; i < servchallen ; i++)
	{
		m_challenge[(i *  seckey[i % seckeylen]) % CHALLENGE_CLIENT_LEN] ^= (char)((m_challenge[i % CHALLENGE_CLIENT_LEN] ^ servchal[i]) & 0xFF);
	}
	
	GOACryptState m_crypt_state;
	int header_size = 1 + CHALLENGE_CRYPT_LEN + 1 + CHALLENGE_SERVER_LEN;
	
	ss.str("");
	for(int i = header_size; i < response.size(); i++)
	{
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(response[i]);
	}
	Logger::debug("encrypted data = " + ss.str());
	
	// Initialization GOA crypt
	GOACryptInit(&(m_crypt_state), (unsigned char *)(&m_challenge), CHALLENGE_CLIENT_LEN);	
	
	// Decrypt data
	GOADecrypt(&(m_crypt_state), (&response[header_size]), response.size() - header_size);
	
	ss.str("");
	for(int i = header_size; i < response.size(); i++)
	{
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(response[i]);
	}
	Logger::debug("decrypted data = " + ss.str());
	
	/*
	// Encrypt the data again to confirm its the right encrypted data
	GOACryptState m_crypt_state2;
	GOACryptInit(&(m_crypt_state2), (unsigned char *)(&m_challenge), CHALLENGE_CLIENT_LEN);	
	GOAEncrypt(&(m_crypt_state2), (&response[header_size]), response.size() - header_size);
	
	ss.str("");
	for(int i = header_size; i < response.size(); i++)
	{
		ss << std::hex << (int)(response[i]);
	}
	Logger::debug("encrypt data = " + ss.str());
	*/
}

void Browsing::Client::Crack()
{
	std::stringstream ss;
	
	uint8_t crypt_challenge[CHALLENGE_CRYPT_LEN];
	uint8_t server_challenge[CHALLENGE_SERVER_LEN];
	uint8_t client_challenge[CHALLENGE_CLIENT_LEN];
	uint8_t key_challenge[CHALLENGE_CLIENT_LEN];
	
	std::vector<unsigned char> request = example_C_request;
	std::vector<unsigned char> response = example_C_response;
	std::vector<unsigned char> decrypted_data = example_C_decrypt_data;
	
	// copy crypt challenge
	ss.str("");
	for(int i = 0; i < CHALLENGE_CRYPT_LEN; i++)
	{
		crypt_challenge[i] = response[1 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(crypt_challenge[i]);
	}
	Logger::debug("crypt_challenge = " + ss.str());
	
	ss.str("");
	for(int i = 0; i < CHALLENGE_SERVER_LEN; i++)
	{
		server_challenge[i] = response[12 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(server_challenge[i]);
	}
	Logger::debug("server_challenge = " + ss.str());
	
	// Get the challenge from the clients request
	ss.str("");
	for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
	{
		client_challenge[i] = request[37 + i];
		ss << std::hex << std::setfill('0') << std::setw(2) << (int)(client_challenge[i]);
	}
	Logger::debug("client_challenge = " + ss.str());
	
	/*
		Crack
	*/
	std::string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	std::vector<unsigned char> encryted_data(16, 0x0);
	
	while(true)
	{
		std::string secret_key = "123456";
		
		// Generate random secret key
		for(int i = 0; i < 6; i++)
		{
			secret_key[i] = alphabet[rand() % alphabet.size()];
		}
		
		// Copy backup challenge
		for(int i = 0; i < CHALLENGE_CLIENT_LEN; i++)
		{
			key_challenge[i] = client_challenge[i];
		}
		
		// Update challenge
		for (uint32_t i = 0 ; i < CHALLENGE_SERVER_LEN; i++)
		{
			key_challenge[(i *  secret_key[i % 6]) % CHALLENGE_CLIENT_LEN] ^= (char)((key_challenge[i % CHALLENGE_CLIENT_LEN] ^ server_challenge[i]) & 0xFF);
		}
		
		// Copy encrypted data
		for(int i = 0; i < 8; i++)
		{
			encryted_data[i] = response[CHALLENGE_CRYPT_LEN + CHALLENGE_SERVER_LEN + 2 + i];
		}
		
		GOACryptState m_crypt_state2;
		GOACryptInit(&(m_crypt_state2), (unsigned char *)(&key_challenge), CHALLENGE_CLIENT_LEN);	
		GOADecrypt(&(m_crypt_state2), &encryted_data[0], 8);
		
		bool correct = true;
		for(int i = 0; i < 8 && correct; i++)
			if(encryted_data[i] != decrypted_data[i])
				correct = false;
		
		if(correct)
		{
			Logger::debug("Found!! secret_key = " + secret_key);
			
			return;
		}
    }
}

